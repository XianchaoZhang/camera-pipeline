<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Halide: Halide::Internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_halide_1_1_internal.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_elf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_elf.html">Elf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_generator_min_max"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html">GeneratorMinMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_integer_division"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_integer_division.html">IntegerDivision</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_introspection"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_introspection.html">Introspection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of two expressions.  <a href="struct_halide_1_1_internal_1_1_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">all_are_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name.html">all_ints_and_optional_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name_3_01_first_00_01_rest_8_8_8_01_4.html">all_ints_and_optional_name&lt; First, Rest... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name_3_01_t_01_4.html">all_ints_and_optional_name&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__ints__and__optional__name_3_4.html">all_ints_and_optional_name&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html">Allocate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a> a scratch area called with the given name, type, and size.  <a href="struct_halide_1_1_internal_1_1_allocate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and - are both expressions true.  <a href="struct_halide_1_1_internal_1_1_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_apply_split_result.html">ApplySplitResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the 'condition' is false, then evaluate and return the message, which should be a call to an error function.  <a href="struct_halide_1_1_internal_1_1_assert_stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent the equivalent associative op of an update definition.  <a href="struct_halide_1_1_internal_1_1_associative_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent an associative op with its identity.  <a href="struct_halide_1_1_internal_1_1_associative_pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for expression nodes.  <a href="struct_halide_1_1_internal_1_1_base_expr_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_stmt_node.html">BaseStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are split into expressions and statements.  <a href="struct_halide_1_1_internal_1_1_base_stmt_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of statements to be executed in-order.  <a href="struct_halide_1_1_internal_1_1_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_bound.html">Bound</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the bounds of a region of arbitrary dimension.  <a href="struct_halide_1_1_internal_1_1_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html">Broadcast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with 'lanes' elements, in which every element is 'value'.  <a href="struct_halide_1_1_internal_1_1_broadcast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_builder.html">BufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A builder to help create Exprs representing <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> structs (e.g.  <a href="struct_halide_1_1_internal_1_1_buffer_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_contents.html">BufferContents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_info.html">BufferInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all calls to image buffers in the function.  <a href="struct_halide_1_1_internal_1_1_buffer_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function call.  <a href="struct_halide_1_1_internal_1_1_call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual IR nodes begin here.  <a href="struct_halide_1_1_internal_1_1_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to manage closures.  <a href="class_halide_1_1_internal_1_1_closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html">CodeGen_ARM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits ARM code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___c.html">CodeGen_C</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class emits C++ code equivalent to a halide <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>.  <a href="class_halide_1_1_internal_1_1_code_gen___c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___d3_d12_compute___dev.html">CodeGen_D3D12Compute_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l.html">CodeGen_GLSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile one statement into GLSL.  <a href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l_base.html">CodeGen_GLSLBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class handles GLSL arithmetic, shared by <a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l.html" title="Compile one statement into GLSL. ">CodeGen_GLSL</a> and CodeGen_OpenGLCompute_C.  <a href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html">CodeGen_GPU_Host</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___hexagon.html">CodeGen_Hexagon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits Hexagon code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___hexagon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html">CodeGen_LLVM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator abstract base class.  <a href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___metal___dev.html">CodeGen_Metal_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___m_i_p_s.html">CodeGen_MIPS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits mips code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___m_i_p_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_c_l___dev.html">CodeGen_OpenCL_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_g_l___dev.html">CodeGen_OpenGL_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_g_l_compute___dev.html">CodeGen_OpenGLCompute_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits posix code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___posix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___power_p_c.html">CodeGen_PowerPC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits mips code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___power_p_c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___p_t_x___dev.html">CodeGen_PTX_Dev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___p_t_x___dev.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___py_torch.html">CodeGen_PyTorch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___x86.html">CodeGen_X86</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits x86 code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___x86.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_cost.html">Cost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1debug.html">debug</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> optional debugging during codegen, use the debug class as follows:  <a href="class_halide_1_1_internal_1_1debug.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition which can either represent a init or an update definition.  <a href="class_halide_1_1_internal_1_1_definition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html">DeviceArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html" title="A DeviceArgument looks similar to an Halide::Argument, but has behavioral differences that make it sp...">DeviceArgument</a> looks similar to an <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function. ">Halide::Argument</a>, but has behavioral differences that make it specific to the GPU pipeline; the fact that neither is-a nor has-a <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function. ">Halide::Argument</a> is deliberate.  <a href="struct_halide_1_1_internal_1_1_device_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_dimension.html">Dimension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ratio of two expressions.  <a href="struct_halide_1_1_internal_1_1_div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression equal to the second.  <a href="struct_halide_1_1_internal_1_1_e_q.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_error_report.html">ErrorReport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html">Evaluate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> and discard an expression, presumably because it has some side-effect.  <a href="struct_halide_1_1_internal_1_1_evaluate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_node.html">ExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We use the "curiously recurring template pattern" to avoid duplicated code in the IR Nodes.  <a href="struct_halide_1_1_internal_1_1_expr_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_expr_uses_vars.html">ExprUsesVars</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_with_compare_cache.html">ExprWithCompareCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper about Exprs so that they can be deeply compared with a cache for known-equal subexpressions.  <a href="struct_halide_1_1_internal_1_1_expr_with_compare_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_find_all_calls.html">FindAllCalls</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for keeping track of functions that are directly called and the arguments with which they are called.  <a href="class_halide_1_1_internal_1_1_find_all_calls.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html">FloatImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point constants.  <a href="struct_halide_1_1_internal_1_1_float_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_for.html">For</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop.  <a href="struct_halide_1_1_internal_1_1_for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_free.html">Free</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_free.html" title="Free the resources associated with the given buffer. ">Free</a> the resources associated with the given buffer.  <a href="struct_halide_1_1_internal_1_1_free.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_func_schedule.html">FuncSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A schedule for a <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> of a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> pipeline.  <a href="class_halide_1_1_internal_1_1_func_schedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s internal representation of a function.  <a href="class_halide_1_1_internal_1_1_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A possibly-weak pointer to a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> function.  <a href="struct_halide_1_1_internal_1_1_function_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_fused_pair.html">FusedPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents two stages with fused loop nests from outermost to a specific loop level.  <a href="struct_halide_1_1_internal_1_1_fused_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_g_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">GeneratorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___arithmetic.html">GeneratorInput_Arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___buffer.html">GeneratorInput_Buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___func.html">GeneratorInput_Func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input___scalar.html">GeneratorInput_Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input_base.html">GeneratorInputBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_input_impl.html">GeneratorInputImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___arithmetic.html">GeneratorOutput_Arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___buffer.html">GeneratorOutput_Buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output___func.html">GeneratorOutput_Func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output_base.html">GeneratorOutputBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_output_impl.html">GeneratorOutputImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">GeneratorParam_Arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">GeneratorParam_Bool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">GeneratorParam_Enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___loop_level.html">GeneratorParam_LoopLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___machine_params.html">GeneratorParam_MachineParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___synthetic.html">GeneratorParam_Synthetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">GeneratorParam_Target</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">GeneratorParam_Type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_base.html">GeneratorParamBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_impl.html">GeneratorParamImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html">GeneratorRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_stub.html">GeneratorStub</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_g_i_o_base.html">GIOBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_g_i_o_base.html" title="GIOBase is the base class for all GeneratorInput&lt;&gt; and GeneratorOutput&lt;&gt; instantiations; it is not pa...">GIOBase</a> is the base class for all GeneratorInput&lt;&gt; and GeneratorOutput&lt;&gt; instantiations; it is not part of the public API and should never be used directly by user code.  <a href="class_halide_1_1_internal_1_1_g_i_o_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than the second.  <a href="struct_halide_1_1_internal_1_1_g_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method_3_01_t2_00_01typename_01type__si902d603523cc7c0df71b135e75cbe224.html">has_static_halide_type_method&lt; T2, typename type_sink&lt; decltype(T2::static_halide_type())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_hexagon_alignment_analyzer.html">HexagonAlignmentAnalyzer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_host_closure.html">HostClosure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures. ">Closure</a> modified to inspect GPU-specific memory accesses, and produce a vector of <a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html" title="A DeviceArgument looks similar to an Halide::Argument, but has behavioral differences that make it sp...">DeviceArgument</a> objects.  <a href="class_halide_1_1_internal_1_1_host_closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_if_then_else.html">IfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An if-then-else block.  <a href="struct_halide_1_1_internal_1_1_if_then_else.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_inferred_argument.html">InferredArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inferred argument.  <a href="struct_halide_1_1_internal_1_1_inferred_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1integer__sequence.html">integer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to represent ranges of Exprs.  <a href="struct_halide_1_1_internal_1_1_interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html">IntImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer constants.  <a href="struct_halide_1_1_internal_1_1_int_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive shared pointers have a reference count (a <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> object) stored in the class itself.  <a href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_compare_cache.html">IRCompareCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lossily track known equal exprs with a cache.  <a href="class_halide_1_1_internal_1_1_i_r_compare_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_deep_compare.html">IRDeepCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compare struct suitable for use in std::map and std::set that computes a lexical ordering on IR nodes.  <a href="struct_halide_1_1_internal_1_1_i_r_deep_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_mutator2.html">IRGraphMutator2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutator that caches and reapplies previously-done mutations, so that it can handle graphs of IR that have not had CSE done to them.  <a href="class_halide_1_1_internal_1_1_i_r_graph_mutator2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html">IRGraphVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that walk recursively over the IR without visiting the same node twice.  <a href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are passed around opaque handles to them.  <a href="struct_halide_1_1_internal_1_1_i_r_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated for new use: please use <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html" title="A base class for passes over the IR which modify it (e.g. ">IRMutator2</a> instead.  <a href="class_halide_1_1_internal_1_1_i_r_mutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for passes over the IR which modify it (e.g.  <a href="class_halide_1_1_internal_1_1_i_r_mutator2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base classes for a node in the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> IR.  <a href="struct_halide_1_1_internal_1_1_i_r_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_printer.html">IRPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR. ">IRVisitor</a> that emits IR to the given output stream in a human readable form.  <a href="class_halide_1_1_internal_1_1_i_r_printer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that need to recursively walk over the IR.  <a href="class_halide_1_1_internal_1_1_i_r_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_is_roundtrippable.html">IsRoundtrippable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_handlers.html">JITHandlers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_module.html">JITModule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_j_i_t_shared_runtime.html">JITSharedRuntime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_user_context.html">JITUserContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_l_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let.html">Let</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A let expression, like you might find in a functional language.  <a href="struct_halide_1_1_internal_1_1_let.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html">LetStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The statement form of a let node.  <a href="struct_halide_1_1_internal_1_1_let_stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named symbol if predicate is true. ">Load</a> a value from a named symbol if predicate is true.  <a href="struct_halide_1_1_internal_1_1_load.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_argument.html">LoweredArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> of an argument to a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function. ">LoweredFunc</a>.  <a href="struct_halide_1_1_internal_1_1_lowered_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> of a lowered function.  <a href="struct_halide_1_1_internal_1_1_lowered_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than the second.  <a href="struct_halide_1_1_internal_1_1_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1make__integer__sequence__helper.html">make_integer_sequence_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1make__integer__sequence__helper_3_01_t_00_01_n_00_01_n_01_4.html">make_integer_sequence_helper&lt; T, N, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater of two values.  <a href="struct_halide_1_1_internal_1_1_max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and.html">meta_and</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and_3_01_t1_00_01_args_8_8_8_01_4.html">meta_and&lt; T1, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__or.html">meta_or</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__or_3_01_t1_00_01_args_8_8_8_01_4.html">meta_or&lt; T1, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lesser of two values.  <a href="struct_halide_1_1_internal_1_1_min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of a / b.  <a href="struct_halide_1_1_internal_1_1_mod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of modulus_remainder analysis.  <a href="struct_halide_1_1_internal_1_1_modulus_remainder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The product of two expressions.  <a href="struct_halide_1_1_internal_1_1_mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression not equal to the second.  <a href="struct_halide_1_1_internal_1_1_n_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1next__integer__sequence.html">next_integer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1next__integer__sequence_3_01integer__sequence_3_01_t_00_01_ints_8_8_8_01_4_01_4.html">next_integer_sequence&lt; integer_sequence&lt; T, Ints... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations.html">NoRealizations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations_3_01_t_00_01_args_8_8_8_01_4.html">NoRealizations&lt; T, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_no_realizations_3_4.html">NoRealizations&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_not.html">Not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical not - true if the expression false.  <a href="struct_halide_1_1_internal_1_1_not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_object_instance_registry.html">ObjectInstanceRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or - is at least one of the expression true.  <a href="struct_halide_1_1_internal_1_1_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a parameter to a halide pipeline.  <a href="class_halide_1_1_internal_1_1_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_prefetch.html">Prefetch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a multi-dimensional region of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> or an <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a> that needs to be prefetched.  <a href="struct_halide_1_1_internal_1_1_prefetch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_producer_consumer.html">ProducerConsumer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is a helpful annotation to do with permissions.  <a href="struct_halide_1_1_internal_1_1_producer_consumer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_provide.html">Provide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the value of a function at a multi-dimensional location.  <a href="struct_halide_1_1_internal_1_1_provide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_python_extension_gen.html">PythonExtensionGen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_ramp.html">Ramp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear ramp vector node.  <a href="struct_halide_1_1_internal_1_1_ramp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-dimensional span.  <a href="struct_halide_1_1_internal_1_1_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_realize.html">Realize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a> a multi-dimensional buffer of the given type and size.  <a href="struct_halide_1_1_internal_1_1_realize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle on a reduction domain, which is just a vector of <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html" title="A single named dimension of a reduction domain. ">ReductionVariable</a>.  <a href="class_halide_1_1_internal_1_1_reduction_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single named dimension of a reduction domain.  <a href="struct_halide_1_1_internal_1_1_reduction_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of reduction variables the expression or tuple depends on.  <a href="struct_halide_1_1_internal_1_1_reduction_variable_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a reference count to be used with <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html" title="Intrusive shared pointers have a reference count (a RefCount object) stored in the class itself...">IntrusivePtr</a>.  <a href="class_halide_1_1_internal_1_1_ref_count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_region_costs.html">RegionCosts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto scheduling component which is used to assign costs for computing a region of a function or one of its stages.  <a href="struct_halide_1_1_internal_1_1_region_costs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_registered_parameter.html">RegisteredParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Subclass of <a class="el" href="class_halide_1_1_internal_1_1_parameter.html" title="A reference-counted handle to a parameter to a halide pipeline. ">Parameter</a> which registers itself in the <a class="el" href="class_halide_1_1_internal_1_1_object_instance_registry.html">ObjectInstanceRegistry</a>; this is provided for backwards compatibility with legacy <a class="el" href="class_halide_1_1_generator.html">Generator</a> code that uses ImageParam/Param instead of Input.  <a href="class_halide_1_1_internal_1_1_registered_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_register_generator.html">RegisterGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_schedule_param_base.html">ScheduleParamBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A common pattern when traversing <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> IR is that you need to keep track of stuff when you find a <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language. ">Let</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a>, and that it should hide previous values with the same name until you leave the <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language. ">Let</a> or <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a> nodes This class helps with that.  <a href="class_halide_1_1_internal_1_1_scope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_binding.html">ScopedBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for pushing/popping Scope&lt;&gt; values, to allow for early-exit in Visitor/Mutators that preserves correctness.  <a href="struct_halide_1_1_internal_1_1_scoped_binding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_binding_3_01void_01_4.html">ScopedBinding&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_scoped_value.html">ScopedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for saving/restoring variable values on the stack, to allow for early-exit that preserves correctness.  <a href="struct_halide_1_1_internal_1_1_scoped_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_select.html">Select</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ternary operator.  <a href="struct_halide_1_1_internal_1_1_select.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type_3_01_first_01_4.html">select_type&lt; First &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_shuffle.html">Shuffle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new vector by taking elements from another sequence of vectors.  <a href="struct_halide_1_1_internal_1_1_shuffle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_stack.html">SmallStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack which can store one item very efficiently.  <a href="class_halide_1_1_internal_1_1_small_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_stack_3_01void_01_4.html">SmallStack&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A schedule for a single stage of a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> pipeline.  <a href="class_halide_1_1_internal_1_1_stage_schedule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_static_cast.html">StaticCast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a statement node.  <a href="struct_halide_1_1_internal_1_1_stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt_node.html">StmtNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_storage_dim.html">StorageDim</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_store.html">Store</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true. ">Store</a> a 'value' to the buffer called 'name' at a given 'index' if 'predicate' is true.  <a href="struct_halide_1_1_internal_1_1_store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html">StringImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String constants.  <a href="struct_halide_1_1_internal_1_1_string_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_string_or_loop_level.html">StringOrLoopLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_input.html">StubInput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_input_buffer.html">StubInputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_stub_input_buffer.html" title="StubInputBuffer is the placeholder that a Stub uses when it requires a Buffer for an input (rather th...">StubInputBuffer</a> is the placeholder that a Stub uses when it requires a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer. ">Buffer</a> for an input (rather than merely a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> or <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>).  <a href="class_halide_1_1_internal_1_1_stub_input_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer.html">StubOutputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer.html" title="StubOutputBuffer is the placeholder that a Stub uses when it requires a Buffer for an output (rather ...">StubOutputBuffer</a> is the placeholder that a Stub uses when it requires a <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer. ">Buffer</a> for an output (rather than merely a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>).  <a href="class_halide_1_1_internal_1_1_stub_output_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stub_output_buffer_base.html">StubOutputBufferBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The difference of two expressions.  <a href="struct_halide_1_1_internal_1_1_sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_temporary_file.html">TemporaryFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple utility class that creates a temporary file in its ctor and deletes that file in its dtor; this is useful for temporary files that you want to ensure are deleted when exiting a certain scope.  <a href="class_halide_1_1_internal_1_1_temporary_file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_thread_pool.html">ThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1type__sink.html">type_sink</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html">UIntImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer constants.  <a href="struct_halide_1_1_internal_1_1_u_int_imm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_value_tracker.html">ValueTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_value_tracker.html" title="ValueTracker is an internal utility class that attempts to track and flag certain obvious Stub-relate...">ValueTracker</a> is an internal utility class that attempts to track and flag certain obvious Stub-related errors at <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> compile time: it tracks the constraints set on any Parameter-based argument (i.e., Input&lt;Buffer&gt; and Output&lt;Buffer&gt;) to ensure that incompatible values aren't set.  <a href="class_halide_1_1_internal_1_1_value_tracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A named variable.  <a href="struct_halide_1_1_internal_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_voidifier.html">Voidifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abff8dba5612d856cc2acfab99e3cf479"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a></td></tr>
<tr class="separator:abff8dba5612d856cc2acfab99e3cf479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0611a86047e2c583dd061a620dcc6e"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a></td></tr>
<tr class="separator:aaa0611a86047e2c583dd061a620dcc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c76d77a93240aaabd916abf0b10beb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ae0c76d77a93240aaabd916abf0b10beb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae0c76d77a93240aaabd916abf0b10beb">add_const_if_T_is_const</a> = typename std::conditional&lt; std::is_const&lt; T &gt;::value, const T2, T2 &gt;::type</td></tr>
<tr class="separator:ae0c76d77a93240aaabd916abf0b10beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee415bddc2cb4a392f5411485d740d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9ee415bddc2cb4a392f5411485d740d0">FuncBounds</a> = std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt;</td></tr>
<tr class="separator:a9ee415bddc2cb4a392f5411485d740d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ad95b1366360901b824afd5282754f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4ad95b1366360901b824afd5282754f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac4ad95b1366360901b824afd5282754f">GeneratorParamImplBase</a> = typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, <a class="el" href="struct_halide_1_1_target.html">Target</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">GeneratorParam_Target</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, <a class="el" href="struct_halide_1_1_machine_params.html">MachineParams</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___machine_params.html">GeneratorParam_MachineParams</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, <a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___loop_level.html">GeneratorParam_LoopLevel</a> &gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">GeneratorParam_Type</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; T, bool &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">GeneratorParam_Bool</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_arithmetic&lt; T &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">GeneratorParam_Arithmetic</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_enum&lt; T &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">GeneratorParam_Enum</a>&lt; T &gt;&gt; &gt;::type</td></tr>
<tr class="separator:ac4ad95b1366360901b824afd5282754f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f2df17f3c13c09f5cbd2672f2a6902"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:aa4f2df17f3c13c09f5cbd2672f2a6902"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa4f2df17f3c13c09f5cbd2672f2a6902">GeneratorInputImplBase</a> = typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a>&lt; TBase &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___buffer.html">GeneratorInput_Buffer</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; TBase, <a class="el" href="class_halide_1_1_func.html">Func</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___func.html">GeneratorInput_Func</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_arithmetic&lt; TBase &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___arithmetic.html">GeneratorInput_Arithmetic</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_scalar&lt; TBase &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___scalar.html">GeneratorInput_Scalar</a>&lt; T &gt;&gt; &gt;::type</td></tr>
<tr class="separator:aa4f2df17f3c13c09f5cbd2672f2a6902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65269e471e6b0c035abc3e3be6d3185b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:a65269e471e6b0c035abc3e3be6d3185b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a65269e471e6b0c035abc3e3be6d3185b">GeneratorOutputImplBase</a> = typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a>&lt; TBase &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___buffer.html">GeneratorOutput_Buffer</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_same&lt; TBase, <a class="el" href="class_halide_1_1_func.html">Func</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___func.html">GeneratorOutput_Func</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt; std::is_arithmetic&lt; TBase &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___arithmetic.html">GeneratorOutput_Arithmetic</a>&lt; T &gt;&gt; &gt;::type</td></tr>
<tr class="separator:a65269e471e6b0c035abc3e3be6d3185b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232fef1d5718a2d032a8f82b11ea1633"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a232fef1d5718a2d032a8f82b11ea1633">GeneratorFactory</a> = std::function&lt; std::unique_ptr&lt; <a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">GeneratorBase</a> &gt;(const <a class="el" href="class_halide_1_1_generator_context.html">GeneratorContext</a> &amp;)&gt;</td></tr>
<tr class="separator:a232fef1d5718a2d032a8f82b11ea1633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e2eb6b31542f36a2c879aa18c48a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e4e2eb6b31542f36a2c879aa18c48a7">GeneratorParamsMap</a> = std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_string_or_loop_level.html">StringOrLoopLevel</a> &gt;</td></tr>
<tr class="separator:a9e4e2eb6b31542f36a2c879aa18c48a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1b9521b6f1f513178f281d8f395335"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a></td></tr>
<tr class="memdesc:abd1b9521b6f1f513178f281d8f395335"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional box.  <a href="#abd1b9521b6f1f513178f281d8f395335">More...</a><br /></td></tr>
<tr class="separator:abd1b9521b6f1f513178f281d8f395335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab837f22cfa4bfe22dba01f4908e839ff"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab837f22cfa4bfe22dba01f4908e839ff">halide_task</a>) (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td></tr>
<tr class="separator:ab837f22cfa4bfe22dba01f4908e839ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7114c2dcec2af79da28735c5b11c0916"><td class="memItemLeft" align="right" valign="top">typedef llvm::raw_pwrite_stream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">LLVMOStream</a></td></tr>
<tr class="separator:a7114c2dcec2af79da28735c5b11c0916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7acd6f64d4adf2c1b53c8931c3d0b87"><td class="memTemplParams" colspan="2">template&lt;typename T , T N&gt; </td></tr>
<tr class="memitem:af7acd6f64d4adf2c1b53c8931c3d0b87"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af7acd6f64d4adf2c1b53c8931c3d0b87">make_integer_sequence</a> = typename <a class="el" href="struct_halide_1_1_internal_1_1make__integer__sequence__helper.html">make_integer_sequence_helper</a>&lt; T, 0, N &gt;::type</td></tr>
<tr class="separator:af7acd6f64d4adf2c1b53c8931c3d0b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d7a7bcb6b4a7de95e27c3234a36c68"><td class="memTemplParams" colspan="2">template&lt;size_t... Ints&gt; </td></tr>
<tr class="memitem:ac5d7a7bcb6b4a7de95e27c3234a36c68"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac5d7a7bcb6b4a7de95e27c3234a36c68">index_sequence</a> = <a class="el" href="struct_halide_1_1_internal_1_1integer__sequence.html">integer_sequence</a>&lt; <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>, Ints... &gt;</td></tr>
<tr class="separator:ac5d7a7bcb6b4a7de95e27c3234a36c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77432e592449f569978b6aabd58831f0"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a77432e592449f569978b6aabd58831f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a77432e592449f569978b6aabd58831f0">make_index_sequence</a> = <a class="el" href="namespace_halide_1_1_internal.html#af7acd6f64d4adf2c1b53c8931c3d0b87">make_integer_sequence</a>&lt; <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>, N &gt;</td></tr>
<tr class="separator:a77432e592449f569978b6aabd58831f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acdd1e32e936b40a5ae1a2a1ef41b64c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acdd1e32e936b40a5ae1a2a1ef41b64c0">add_image_checks</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;fb)</td></tr>
<tr class="memdesc:acdd1e32e936b40a5ae1a2a1ef41b64c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert checks to make sure a statement doesn't read out of bounds on inputs or outputs, and that the inputs and outputs conform to the format required (e.g.  <a href="#acdd1e32e936b40a5ae1a2a1ef41b64c0">More...</a><br /></td></tr>
<tr class="separator:acdd1e32e936b40a5ae1a2a1ef41b64c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd151298721810b82ac418d3810a0dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6bd151298721810b82ac418d3810a0dc">add_parameter_checks</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a6bd151298721810b82ac418d3810a0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert checks to make sure that all referenced parameters meet their constraints.  <a href="#a6bd151298721810b82ac418d3810a0dc">More...</a><br /></td></tr>
<tr class="separator:a6bd151298721810b82ac418d3810a0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576b07e3ec78cfaee39c3fb46180be89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a576b07e3ec78cfaee39c3fb46180be89">align_loads</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, int alignment, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment_info)</td></tr>
<tr class="memdesc:a576b07e3ec78cfaee39c3fb46180be89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to rewrite unaligned loads from buffers which are known to be aligned to instead load aligned vectors that cover the original load, and then slice the original load out of the aligned vectors.  <a href="#a576b07e3ec78cfaee39c3fb46180be89">More...</a><br /></td></tr>
<tr class="separator:a576b07e3ec78cfaee39c3fb46180be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410eac3ad68dfb697c5ee97100f2053f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a410eac3ad68dfb697c5ee97100f2053f">allocation_bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds)</td></tr>
<tr class="memdesc:a410eac3ad68dfb697c5ee97100f2053f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes in terms of variables, and define values for those variables.  <a href="#a410eac3ad68dfb697c5ee97100f2053f">More...</a><br /></td></tr>
<tr class="separator:a410eac3ad68dfb697c5ee97100f2053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc30631d84b60819247acdc8d36a5069"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_apply_split_result.html">ApplySplitResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afc30631d84b60819247acdc8d36a5069">apply_split</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;split, bool is_update, std::string prefix, std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;dim_extent_alignment)</td></tr>
<tr class="memdesc:afc30631d84b60819247acdc8d36a5069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> schedule on a definition (init or update), return a list of of predicates on the definition, substitutions that needs to be applied to the definition (in ascending order of application), and let stmts which defined the values of variables referred by the predicates and substitutions (ordered from innermost to outermost let).  <a href="#afc30631d84b60819247acdc8d36a5069">More...</a><br /></td></tr>
<tr class="separator:afc30631d84b60819247acdc8d36a5069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed1719a2195963da99bb290dface983"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4ed1719a2195963da99bb290dface983">compute_loop_bounds_after_split</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;split, std::string prefix)</td></tr>
<tr class="memdesc:a4ed1719a2195963da99bb290dface983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the loop bounds of the new dimensions resulting from applying the split schedules using the loop bounds of the old dimensions.  <a href="#a4ed1719a2195963da99bb290dface983">More...</a><br /></td></tr>
<tr class="separator:a4ed1719a2195963da99bb290dface983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43db81cbccaa74354f14e7f902094ed8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a43db81cbccaa74354f14e7f902094ed8">get_ops_table</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;exprs)</td></tr>
<tr class="separator:a43db81cbccaa74354f14e7f902094ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf049bd392c948b161c1435e23184a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acf049bd392c948b161c1435e23184a20">prove_associativity</a> (const std::string &amp;f, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; args, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; exprs)</td></tr>
<tr class="memdesc:acf049bd392c948b161c1435e23184a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an update definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> 'f', determine its equivalent associative binary/unary operator if there is any.  <a href="#acf049bd392c948b161c1435e23184a20">More...</a><br /></td></tr>
<tr class="separator:acf049bd392c948b161c1435e23184a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a6050713d80d82d1ba201fc9f709b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a74a6050713d80d82d1ba201fc9f709b7">associativity_test</a> ()</td></tr>
<tr class="separator:a74a6050713d80d82d1ba201fc9f709b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976aabd7126fce7f9d7a46daeee8fd40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a976aabd7126fce7f9d7a46daeee8fd40">inline_all_trivial_functions</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a976aabd7126fce7f9d7a46daeee8fd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the cost of computing a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> is about the same as calling the <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>, inline the <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>.  <a href="#a976aabd7126fce7f9d7a46daeee8fd40">More...</a><br /></td></tr>
<tr class="separator:a976aabd7126fce7f9d7a46daeee8fd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0e38c670066041490103529f6c5707"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adb0e38c670066041490103529f6c5707">inline_all_element_wise_functions</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:adb0e38c670066041490103529f6c5707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> if its values are only consumed by another single <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> in element-wise manner.  <a href="#adb0e38c670066041490103529f6c5707">More...</a><br /></td></tr>
<tr class="separator:adb0e38c670066041490103529f6c5707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935bdff64b523568e228fde67dbc6f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a935bdff64b523568e228fde67dbc6f9d">check_estimates_on_outputs</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="memdesc:a935bdff64b523568e228fde67dbc6f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all the pipeline outputs have estimates specified on each of their dimensions; otherwise, throw an assertion.  <a href="#a935bdff64b523568e228fde67dbc6f9d">More...</a><br /></td></tr>
<tr class="separator:a935bdff64b523568e228fde67dbc6f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5840b87d513cf20f47e74eaf5b519d06"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5840b87d513cf20f47e74eaf5b519d06">generate_schedules</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, const <a class="el" href="struct_halide_1_1_machine_params.html">MachineParams</a> &amp;arch_params)</td></tr>
<tr class="memdesc:a5840b87d513cf20f47e74eaf5b519d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate schedules for Funcs within a pipeline.  <a href="#a5840b87d513cf20f47e74eaf5b519d06">More...</a><br /></td></tr>
<tr class="separator:a5840b87d513cf20f47e74eaf5b519d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf8e17b611c700b1a41969a8dc7c1e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acdf8e17b611c700b1a41969a8dc7c1e1">string_to_int</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:acdf8e17b611c700b1a41969a8dc7c1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an int representation of 's'.  <a href="#acdf8e17b611c700b1a41969a8dc7c1e1">More...</a><br /></td></tr>
<tr class="separator:acdf8e17b611c700b1a41969a8dc7c1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f09ed39b20fb0f51fbda5a7b14c7f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7f09ed39b20fb0f51fbda5a7b14c7f93">get_extent</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &amp;i)</td></tr>
<tr class="memdesc:a7f09ed39b20fb0f51fbda5a7b14c7f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of an interval.  <a href="#a7f09ed39b20fb0f51fbda5a7b14c7f93">More...</a><br /></td></tr>
<tr class="separator:a7f09ed39b20fb0f51fbda5a7b14c7f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ce3144d60aa2f3abdb127b3750cb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a09ce3144d60aa2f3abdb127b3750cb73">box_size</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a09ce3144d60aa2f3abdb127b3750cb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of an n-d box.  <a href="#a09ce3144d60aa2f3abdb127b3750cb73">More...</a><br /></td></tr>
<tr class="separator:a09ce3144d60aa2f3abdb127b3750cb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f30fc5e0c64f2e3f32ffe1416f045b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5f30fc5e0c64f2e3f32ffe1416f045b0">disp_regions</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; &amp;regions)</td></tr>
<tr class="memdesc:a5f30fc5e0c64f2e3f32ffe1416f045b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to print the bounds of a region.  <a href="#a5f30fc5e0c64f2e3f32ffe1416f045b0">More...</a><br /></td></tr>
<tr class="separator:a5f30fc5e0c64f2e3f32ffe1416f045b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf44d2ab2c8eca7437d770011107830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4cf44d2ab2c8eca7437d770011107830">get_stage_definition</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f, int stage_num)</td></tr>
<tr class="memdesc:a4cf44d2ab2c8eca7437d770011107830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corresponding definition of a function given the stage.  <a href="#a4cf44d2ab2c8eca7437d770011107830">More...</a><br /></td></tr>
<tr class="separator:a4cf44d2ab2c8eca7437d770011107830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12964871a49b9d9eb81fb01991771150"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a12964871a49b9d9eb81fb01991771150">get_stage_dims</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;f, int stage_num)</td></tr>
<tr class="memdesc:a12964871a49b9d9eb81fb01991771150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the corresponding loop dimensions of a function given the stage.  <a href="#a12964871a49b9d9eb81fb01991771150">More...</a><br /></td></tr>
<tr class="separator:a12964871a49b9d9eb81fb01991771150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753561dbe4e01ef75c2af4ce17d3dfb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a753561dbe4e01ef75c2af4ce17d3dfb1">combine_load_costs</a> (std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;partial)</td></tr>
<tr class="memdesc:a753561dbe4e01ef75c2af4ce17d3dfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> partial load costs to the corresponding function in the result costs.  <a href="#a753561dbe4e01ef75c2af4ce17d3dfb1">More...</a><br /></td></tr>
<tr class="separator:a753561dbe4e01ef75c2af4ce17d3dfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6adfe4d3a789e11392b6e58ee97ac64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af6adfe4d3a789e11392b6e58ee97ac64">get_stage_bounds</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, int stage_num, const <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;pure_bounds)</td></tr>
<tr class="memdesc:af6adfe4d3a789e11392b6e58ee97ac64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the required bounds of an intermediate stage (f, stage_num) of function 'f' given the bounds of the pure dimensions.  <a href="#af6adfe4d3a789e11392b6e58ee97ac64">More...</a><br /></td></tr>
<tr class="separator:af6adfe4d3a789e11392b6e58ee97ac64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf83d33d2ab27e489680b4680a12f66"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4bf83d33d2ab27e489680b4680a12f66">get_stage_bounds</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, const <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;pure_bounds)</td></tr>
<tr class="memdesc:a4bf83d33d2ab27e489680b4680a12f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the required bounds for all the stages of the function 'f'.  <a href="#a4bf83d33d2ab27e489680b4680a12f66">More...</a><br /></td></tr>
<tr class="separator:a4bf83d33d2ab27e489680b4680a12f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b91c6f613e8875eda9c8ae063a86c0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b91c6f613e8875eda9c8ae063a86c0d">perform_inline</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::set&lt; std::string &gt; &amp;inlines=std::set&lt; std::string &gt;())</td></tr>
<tr class="memdesc:a4b91c6f613e8875eda9c8ae063a86c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively inline all the functions in the set 'inlines' into the expression 'e' and return the resulting expression.  <a href="#a4b91c6f613e8875eda9c8ae063a86c0d">More...</a><br /></td></tr>
<tr class="separator:a4b91c6f613e8875eda9c8ae063a86c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6d082a8fe5678245509867a53372c3"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5f6d082a8fe5678245509867a53372c3">get_parents</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, int stage)</td></tr>
<tr class="memdesc:a5f6d082a8fe5678245509867a53372c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all functions that are directly called by a function stage (f, stage).  <a href="#a5f6d082a8fe5678245509867a53372c3">More...</a><br /></td></tr>
<tr class="separator:a5f6d082a8fe5678245509867a53372c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654878c752bfbc9f2aa979007ff80037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a654878c752bfbc9f2aa979007ff80037">propagate_estimate_test</a> ()</td></tr>
<tr class="separator:a654878c752bfbc9f2aa979007ff80037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9191d3b3cba94302c0d08bf9f488d8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9191d3b3cba94302c0d08bf9f488d8c6">bounds_of_expr_in_scope</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope, const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>(), bool const_bound=false)</td></tr>
<tr class="memdesc:a9191d3b3cba94302c0d08bf9f488d8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression.  <a href="#a9191d3b3cba94302c0d08bf9f488d8c6">More...</a><br /></td></tr>
<tr class="separator:a9191d3b3cba94302c0d08bf9f488d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b9d67e1b22b876ec4e3f227557d835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a69b9d67e1b22b876ec4e3f227557d835">find_constant_bound</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">Direction</a> d, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;())</td></tr>
<tr class="separator:a69b9d67e1b22b876ec4e3f227557d835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34593e7612bf139260707200b6dacb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa34593e7612bf139260707200b6dacb3">find_constant_bounds</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:aa34593e7612bf139260707200b6dacb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find bounds for a varying expression that are either constants or +/-inf.  <a href="#aa34593e7612bf139260707200b6dacb3">More...</a><br /></td></tr>
<tr class="separator:aa34593e7612bf139260707200b6dacb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac2f62c0ee3ace8de2be57a9db369a3e4">merge_boxes</a> (<a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand box a to encompass box b.  <a href="#ac2f62c0ee3ace8de2be57a9db369a3e4">More...</a><br /></td></tr>
<tr class="separator:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9641dd947fdf6352ccd5e34548db35e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9641dd947fdf6352ccd5e34548db35e">boxes_overlap</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:ac9641dd947fdf6352ccd5e34548db35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if box a could possibly overlap box b.  <a href="#ac9641dd947fdf6352ccd5e34548db35e">More...</a><br /></td></tr>
<tr class="separator:ac9641dd947fdf6352ccd5e34548db35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86d8a9b260b097d115182e4b8488f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af86d8a9b260b097d115182e4b8488f09">box_union</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:af86d8a9b260b097d115182e4b8488f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The union of two boxes.  <a href="#af86d8a9b260b097d115182e4b8488f09">More...</a><br /></td></tr>
<tr class="separator:af86d8a9b260b097d115182e4b8488f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c57c8cff1c0ff811a01724b58086bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8c57c8cff1c0ff811a01724b58086bdc">box_intersection</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a8c57c8cff1c0ff811a01724b58086bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intersection of two boxes.  <a href="#a8c57c8cff1c0ff811a01724b58086bdc">More...</a><br /></td></tr>
<tr class="separator:a8c57c8cff1c0ff811a01724b58086bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9198438916c78b87c90e665d665a18cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9198438916c78b87c90e665d665a18cd">box_contains</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a9198438916c78b87c90e665d665a18cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if box a provably contains box b.  <a href="#a9198438916c78b87c90e665d665a18cd">More...</a><br /></td></tr>
<tr class="separator:a9198438916c78b87c90e665d665a18cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b807d0d1524fb2f20b1533d05032c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b807d0d1524fb2f20b1533d05032c02">compute_function_value_bounds</a> (const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a0b807d0d1524fb2f20b1533d05032c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum and minimum possible value for each function in an environment.  <a href="#a0b807d0d1524fb2f20b1533d05032c02">More...</a><br /></td></tr>
<tr class="separator:a0b807d0d1524fb2f20b1533d05032c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439ef9127bf30f5e2a67963eb8db0323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a439ef9127bf30f5e2a67963eb8db0323">bounds_test</a> ()</td></tr>
<tr class="separator:a439ef9127bf30f5e2a67963eb8db0323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2369df82ba80121eb935e5ac7076de5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab2369df82ba80121eb935e5ac7076de5">bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;<a class="el" href="namespace_halide_1_1_internal.html#a310daae8e7f187c090b63aa3514d639c">realization_order</a>, const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;fused_groups, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;environment, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:ab2369df82ba80121eb935e5ac7076de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds.  <a href="#ab2369df82ba80121eb935e5ac7076de5">More...</a><br /></td></tr>
<tr class="separator:ab2369df82ba80121eb935e5ac7076de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7428f5e071a4f8c2d89a79afc6b426a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7428f5e071a4f8c2d89a79afc6b426a0">bound_small_allocations</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="separator:a7428f5e071a4f8c2d89a79afc6b426a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b58338c6b3553965f8360efe1d31788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9b58338c6b3553965f8360efe1d31788">buffer_accessor</a> (const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;&gt; &amp;<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:a9b58338c6b3553965f8360efe1d31788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefca0281fde1b4caf8d1d188d4bd809d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;!std::is_convertible&lt;T, std::string&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aefca0281fde1b4caf8d1d188d4bd809d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aefca0281fde1b4caf8d1d188d4bd809d">get_name_from_end_of_parameter_pack</a> (T &amp;&amp;)</td></tr>
<tr class="separator:aefca0281fde1b4caf8d1d188d4bd809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3480ee712c4aecb9425a7e5c540889f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae3480ee712c4aecb9425a7e5c540889f">get_name_from_end_of_parameter_pack</a> (const std::string &amp;n)</td></tr>
<tr class="separator:ae3480ee712c4aecb9425a7e5c540889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016a8762a4f14a3d708461f0d1616bc2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a016a8762a4f14a3d708461f0d1616bc2">get_name_from_end_of_parameter_pack</a> ()</td></tr>
<tr class="separator:a016a8762a4f14a3d708461f0d1616bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ab4586f42653c6b16a6e0ad186f1e5"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Args&gt; </td></tr>
<tr class="memitem:a70ab4586f42653c6b16a6e0ad186f1e5"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70ab4586f42653c6b16a6e0ad186f1e5">get_name_from_end_of_parameter_pack</a> (First first, Second second, Args &amp;&amp;...rest)</td></tr>
<tr class="separator:a70ab4586f42653c6b16a6e0ad186f1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab882d8987fcdb737d28066db1130b509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab882d8987fcdb737d28066db1130b509">get_shape_from_start_of_parameter_pack_helper</a> (std::vector&lt; int &gt; &amp;, const std::string &amp;)</td></tr>
<tr class="separator:ab882d8987fcdb737d28066db1130b509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352d23994d86bd76a8167c6144f3a3dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a352d23994d86bd76a8167c6144f3a3dc">get_shape_from_start_of_parameter_pack_helper</a> (std::vector&lt; int &gt; &amp;)</td></tr>
<tr class="separator:a352d23994d86bd76a8167c6144f3a3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc82b2d635d098a40d4b87018edd0a73"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:afc82b2d635d098a40d4b87018edd0a73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afc82b2d635d098a40d4b87018edd0a73">get_shape_from_start_of_parameter_pack_helper</a> (std::vector&lt; int &gt; &amp;result, int x, Args &amp;&amp;...rest)</td></tr>
<tr class="separator:afc82b2d635d098a40d4b87018edd0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ed87b50654371fbd0e1415c8d52e4e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae7ed87b50654371fbd0e1415c8d52e4e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae7ed87b50654371fbd0e1415c8d52e4e">get_shape_from_start_of_parameter_pack</a> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:ae7ed87b50654371fbd0e1415c8d52e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eefe960250b26cc13e38cb734803057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5eefe960250b26cc13e38cb734803057">canonicalize_gpu_vars</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a5eefe960250b26cc13e38cb734803057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize GPU var names into some pre-determined block/thread names (i.e.  <a href="#a5eefe960250b26cc13e38cb734803057">More...</a><br /></td></tr>
<tr class="separator:a5eefe960250b26cc13e38cb734803057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1e270066706802bc3903a17703f173"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1a1e270066706802bc3903a17703f173">build_closure_type</a> (const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;closure, llvm::StructType *<a class="el" href="structbuffer__t.html">buffer_t</a>, llvm::LLVMContext *context)</td></tr>
<tr class="memdesc:a1a1e270066706802bc3903a17703f173"><td class="mdescLeft">&#160;</td><td class="mdescRight">The llvm type of a struct containing all of the externally referenced state of a <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures. ">Closure</a>.  <a href="#a1a1e270066706802bc3903a17703f173">More...</a><br /></td></tr>
<tr class="separator:a1a1e270066706802bc3903a17703f173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3a7858581f388f494393f77364e53a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adf3a7858581f388f494393f77364e53a">pack_closure</a> (llvm::StructType *type, llvm::Value *<a class="el" href="printer_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>, const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;closure, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; llvm::Value * &gt; &amp;src, llvm::StructType *<a class="el" href="structbuffer__t.html">buffer_t</a>, <a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt; llvm::ConstantFolder, llvm::IRBuilderDefaultInserter &gt; *builder)</td></tr>
<tr class="memdesc:adf3a7858581f388f494393f77364e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that builds a struct containing all the externally referenced state.  <a href="#adf3a7858581f388f494393f77364e53a">More...</a><br /></td></tr>
<tr class="separator:adf3a7858581f388f494393f77364e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0822c4fa8fbb5790406eb22d2d5849ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0822c4fa8fbb5790406eb22d2d5849ca">unpack_closure</a> (const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;closure, <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; llvm::Value * &gt; &amp;<a class="el" href="printer_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>, llvm::StructType *type, llvm::Value *src, <a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt; llvm::ConstantFolder, llvm::IRBuilderDefaultInserter &gt; *builder)</td></tr>
<tr class="memdesc:a0822c4fa8fbb5790406eb22d2d5849ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that unpacks a struct containing all the externally referenced state into a symbol table.  <a href="#a0822c4fa8fbb5790406eb22d2d5849ca">More...</a><br /></td></tr>
<tr class="separator:a0822c4fa8fbb5790406eb22d2d5849ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f10140e29131153c3be98d2899b090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817aa1fa27779242b4902f7ae3bdd5c6d508">llvm::Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a71f10140e29131153c3be98d2899b090">llvm_type_of</a> (llvm::LLVMContext *context, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> t)</td></tr>
<tr class="memdesc:a71f10140e29131153c3be98d2899b090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the llvm type equivalent to a given halide type.  <a href="#a71f10140e29131153c3be98d2899b090">More...</a><br /></td></tr>
<tr class="separator:a71f10140e29131153c3be98d2899b090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc60421b682a09ea4c4dcaaaa3e105e2">function_takes_user_context</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which built-in functions require a user-context first argument?  <a href="#adc60421b682a09ea4c4dcaaaa3e105e2">More...</a><br /></td></tr>
<tr class="separator:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abe6b887804e86f403f0af16d5a2ba1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4abe6b887804e86f403f0af16d5a2ba1">can_allocation_fit_on_stack</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> size)</td></tr>
<tr class="memdesc:a4abe6b887804e86f403f0af16d5a2ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a size (in bytes), return True if the allocation size can fit on the stack; otherwise, return False.  <a href="#a4abe6b887804e86f403f0af16d5a2ba1">More...</a><br /></td></tr>
<tr class="separator:a4abe6b887804e86f403f0af16d5a2ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ab4b5f40c8220a917723d3fe46d736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a83ab4b5f40c8220a917723d3fe46d736">unpredicate_loads_stores</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a83ab4b5f40c8220a917723d3fe46d736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace predicated loads/stores with unpredicated equivalents inside branches.  <a href="#a83ab4b5f40c8220a917723d3fe46d736">More...</a><br /></td></tr>
<tr class="separator:a83ab4b5f40c8220a917723d3fe46d736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4fa94b1f3a877eb3387824c09df826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7b4fa94b1f3a877eb3387824c09df826">get_target_options</a> (const llvm::Module &amp;module, llvm::TargetOptions &amp;options, std::string &amp;mcpu, std::string &amp;mattrs)</td></tr>
<tr class="memdesc:a7b4fa94b1f3a877eb3387824c09df826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an llvm::Module, set llvm:TargetOptions, cpu and attr information.  <a href="#a7b4fa94b1f3a877eb3387824c09df826">More...</a><br /></td></tr>
<tr class="separator:a7b4fa94b1f3a877eb3387824c09df826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b16d175882e16f544bf4bf92ec931b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1b16d175882e16f544bf4bf92ec931b5">clone_target_options</a> (const llvm::Module &amp;from, llvm::Module &amp;to)</td></tr>
<tr class="memdesc:a1b16d175882e16f544bf4bf92ec931b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two llvm::Modules, clone target options from one to the other.  <a href="#a1b16d175882e16f544bf4bf92ec931b5">More...</a><br /></td></tr>
<tr class="separator:a1b16d175882e16f544bf4bf92ec931b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e20aff45028d266f854487159df341"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::TargetMachine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af1e20aff45028d266f854487159df341">make_target_machine</a> (const llvm::Module &amp;module)</td></tr>
<tr class="memdesc:af1e20aff45028d266f854487159df341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an llvm::Module, get or create an llvm:TargetMachine.  <a href="#af1e20aff45028d266f854487159df341">More...</a><br /></td></tr>
<tr class="separator:af1e20aff45028d266f854487159df341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe55211c4dbc852f29c8e764360c670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abfe55211c4dbc852f29c8e764360c670">set_function_attributes_for_target</a> (<a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261">llvm::Function</a> *, <a class="el" href="struct_halide_1_1_target.html">Target</a>)</td></tr>
<tr class="memdesc:abfe55211c4dbc852f29c8e764360c670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the appropriate llvm <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> attributes given a <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#abfe55211c4dbc852f29c8e764360c670">More...</a><br /></td></tr>
<tr class="separator:abfe55211c4dbc852f29c8e764360c670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9170638fdb8e1cb975e1ff7fb561a560"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9170638fdb8e1cb975e1ff7fb561a560">cplusplus_function_mangled_name</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;namespaces, <a class="el" href="struct_halide_1_1_type.html">Type</a> return_type, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;args, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a9170638fdb8e1cb975e1ff7fb561a560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mangled C++ name for a function.  <a href="#a9170638fdb8e1cb975e1ff7fb561a560">More...</a><br /></td></tr>
<tr class="separator:a9170638fdb8e1cb975e1ff7fb561a560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d63fc361474a95f58c2839461cc7df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a67d63fc361474a95f58c2839461cc7df">cplusplus_mangle_test</a> ()</td></tr>
<tr class="separator:a67d63fc361474a95f58c2839461cc7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2af44447b9269918e9d63d948ea8bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5f2af44447b9269918e9d63d948ea8bd">common_subexpression_elimination</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;, bool lift_all=false)</td></tr>
<tr class="memdesc:a5f2af44447b9269918e9d63d948ea8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable.  <a href="#a5f2af44447b9269918e9d63d948ea8bd">More...</a><br /></td></tr>
<tr class="separator:a5f2af44447b9269918e9d63d948ea8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03dcb48bcb8e81238a1c6cfea195e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac03dcb48bcb8e81238a1c6cfea195e1a">common_subexpression_elimination</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;, bool lift_all=false)</td></tr>
<tr class="memdesc:ac03dcb48bcb8e81238a1c6cfea195e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do common-subexpression-elimination on each expression in a statement.  <a href="#ac03dcb48bcb8e81238a1c6cfea195e1a">More...</a><br /></td></tr>
<tr class="separator:ac03dcb48bcb8e81238a1c6cfea195e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cbc086e9926046bdb9f4ade681111a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a88cbc086e9926046bdb9f4ade681111a">cse_test</a> ()</td></tr>
<tr class="separator:a88cbc086e9926046bdb9f4ade681111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98f0a702bd775e67baed5bcd986ae27"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab98f0a702bd775e67baed5bcd986ae27">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:ab98f0a702bd775e67baed5bcd986ae27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide statement on an output stream (such as std::cout) in a human-readable form.  <a href="#ab98f0a702bd775e67baed5bcd986ae27">More...</a><br /></td></tr>
<tr class="separator:ab98f0a702bd775e67baed5bcd986ae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029791644c90ea7a194d58fc87ab41bf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a029791644c90ea7a194d58fc87ab41bf">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;)</td></tr>
<tr class="memdesc:a029791644c90ea7a194d58fc87ab41bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function. ">LoweredFunc</a> in a human readable format.  <a href="#a029791644c90ea7a194d58fc87ab41bf">More...</a><br /></td></tr>
<tr class="separator:a029791644c90ea7a194d58fc87ab41bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380f859ef78573f0f630f6ca2a392e6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a380f859ef78573f0f630f6ca2a392e6f">debug_arguments</a> (<a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> *func)</td></tr>
<tr class="memdesc:a380f859ef78573f0f630f6ca2a392e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects debug prints in a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function. ">LoweredFunc</a> that describe the arguments.  <a href="#a380f859ef78573f0f630f6ca2a392e6f">More...</a><br /></td></tr>
<tr class="separator:a380f859ef78573f0f630f6ca2a392e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea2b563fa94726a65b596979b9d2f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaea2b563fa94726a65b596979b9d2f85">debug_to_file</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:aaea2b563fa94726a65b596979b9d2f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes still unlowered.  <a href="#aaea2b563fa94726a65b596979b9d2f85">More...</a><br /></td></tr>
<tr class="separator:aaea2b563fa94726a65b596979b9d2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9b678f3916b022dd8b8415c9ca0750"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaa9b678f3916b022dd8b8415c9ca0750">extract_odd_lanes</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:aaa9b678f3916b022dd8b8415c9ca0750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the odd-numbered lanes in a vector.  <a href="#aaa9b678f3916b022dd8b8415c9ca0750">More...</a><br /></td></tr>
<tr class="separator:aaa9b678f3916b022dd8b8415c9ca0750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017315ab942e526e9915325f05d406a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a017315ab942e526e9915325f05d406a0">extract_even_lanes</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a017315ab942e526e9915325f05d406a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the even-numbered lanes in a vector.  <a href="#a017315ab942e526e9915325f05d406a0">More...</a><br /></td></tr>
<tr class="separator:a017315ab942e526e9915325f05d406a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750c306ff019e4f332238799979c9345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a750c306ff019e4f332238799979c9345">extract_lane</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> vec, int lane)</td></tr>
<tr class="memdesc:a750c306ff019e4f332238799979c9345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the nth lane of a vector.  <a href="#a750c306ff019e4f332238799979c9345">More...</a><br /></td></tr>
<tr class="separator:a750c306ff019e4f332238799979c9345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1233a717a83d74121106b95245ce81a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac1233a717a83d74121106b95245ce81a">rewrite_interleavings</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:ac1233a717a83d74121106b95245ce81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic.  <a href="#ac1233a717a83d74121106b95245ce81a">More...</a><br /></td></tr>
<tr class="separator:ac1233a717a83d74121106b95245ce81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc1b0ff156c8b0ca5fd26956ee482a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8dc1b0ff156c8b0ca5fd26956ee482a9">deinterleave_vector_test</a> ()</td></tr>
<tr class="separator:a8dc1b0ff156c8b0ca5fd26956ee482a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b09a9a7a36079688446d7d49dd2f901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7b09a9a7a36079688446d7d49dd2f901">derivative_test</a> ()</td></tr>
<tr class="separator:a7b09a9a7a36079688446d7d49dd2f901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd8e9020c7517c9cce8212ec8660561"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5dd8e9020c7517c9cce8212ec8660561">has_variable</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::string &amp;name)</td></tr>
<tr class="memdesc:a5dd8e9020c7517c9cce8212ec8660561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if expr depends on the variable.  <a href="#a5dd8e9020c7517c9cce8212ec8660561">More...</a><br /></td></tr>
<tr class="separator:a5dd8e9020c7517c9cce8212ec8660561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599ceaaeeb259fa775831b46da41c66b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a599ceaaeeb259fa775831b46da41c66b">has_let_defined</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::string &amp;name)</td></tr>
<tr class="memdesc:a599ceaaeeb259fa775831b46da41c66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if expr has a <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language. ">Let</a> operation defining the variable.  <a href="#a599ceaaeeb259fa775831b46da41c66b">More...</a><br /></td></tr>
<tr class="separator:a599ceaaeeb259fa775831b46da41c66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d3c39b97b822e2c3e50a1c977441aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa8d3c39b97b822e2c3e50a1c977441aa">remove_let_definitions</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aa8d3c39b97b822e2c3e50a1c977441aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all let definitions of expr.  <a href="#aa8d3c39b97b822e2c3e50a1c977441aa">More...</a><br /></td></tr>
<tr class="separator:aa8d3c39b97b822e2c3e50a1c977441aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c4e4e271de96594d3b461a3255f4bd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae8c4e4e271de96594d3b461a3255f4bd">gather_variables</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::vector&lt; std::string &gt; &amp;filter)</td></tr>
<tr class="memdesc:ae8c4e4e271de96594d3b461a3255f4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of variables that expr depends on and are in the filter.  <a href="#ae8c4e4e271de96594d3b461a3255f4bd">More...</a><br /></td></tr>
<tr class="separator:ae8c4e4e271de96594d3b461a3255f4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb392e8cddbe26a58fd90ed22cd173b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3fb392e8cddbe26a58fd90ed22cd173b">gather_variables</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;filter)</td></tr>
<tr class="separator:a3fb392e8cddbe26a58fd90ed22cd173b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed831839271449ac11b2cadb24003e4c"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aed831839271449ac11b2cadb24003e4c">gather_rvariables</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="separator:aed831839271449ac11b2cadb24003e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9113ee099078cd921abc0b6151e5669e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9113ee099078cd921abc0b6151e5669e">gather_rvariables</a> (<a class="el" href="class_halide_1_1_tuple.html">Tuple</a> tuple)</td></tr>
<tr class="separator:a9113ee099078cd921abc0b6151e5669e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b66032c9826d25bfa470c4c974081d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9b66032c9826d25bfa470c4c974081d5">add_let_expression</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;let_var_mapping, const std::vector&lt; std::string &gt; &amp;let_variables)</td></tr>
<tr class="memdesc:a9b66032c9826d25bfa470c4c974081d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> necessary let expressions to expr.  <a href="#a9b66032c9826d25bfa470c4c974081d5">More...</a><br /></td></tr>
<tr class="separator:a9b66032c9826d25bfa470c4c974081d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8422615887974b7d347d7b069e592ced"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8422615887974b7d347d7b069e592ced">sort_expressions</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a8422615887974b7d347d7b069e592ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically sort the expression graph expressed by expr.  <a href="#a8422615887974b7d347d7b069e592ced">More...</a><br /></td></tr>
<tr class="separator:a8422615887974b7d347d7b069e592ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9cd05798adb83f7286b3d0d0789d55"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace9cd05798adb83f7286b3d0d0789d55">inference_bounds</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;funcs, const std::vector&lt; <a class="el" href="namespace_halide_1_1_internal.html#a9ee415bddc2cb4a392f5411485d740d0">FuncBounds</a> &gt; &amp;output_bounds)</td></tr>
<tr class="memdesc:ace9cd05798adb83f7286b3d0d0789d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounds of funcs.  <a href="#ace9cd05798adb83f7286b3d0d0789d55">More...</a><br /></td></tr>
<tr class="separator:ace9cd05798adb83f7286b3d0d0789d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8109bfe3edb53d92d18c7cea459d837"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af8109bfe3edb53d92d18c7cea459d837">inference_bounds</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;func, const <a class="el" href="namespace_halide_1_1_internal.html#a9ee415bddc2cb4a392f5411485d740d0">FuncBounds</a> &amp;output_bounds)</td></tr>
<tr class="separator:af8109bfe3edb53d92d18c7cea459d837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeff30be2f05a33246906cb93c5ef840"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abeff30be2f05a33246906cb93c5ef840">box_to_vector</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;bounds)</td></tr>
<tr class="memdesc:abeff30be2f05a33246906cb93c5ef840"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> <a class="el" href="struct_halide_1_1_internal_1_1_box.html" title="Represents the bounds of a region of arbitrary dimension. ">Box</a> to vector of (min, extent)  <a href="#abeff30be2f05a33246906cb93c5ef840">More...</a><br /></td></tr>
<tr class="separator:abeff30be2f05a33246906cb93c5ef840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d062e9354cd14001f47cd01e82b93a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a44d062e9354cd14001f47cd01e82b93a">equal</a> (const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;bounds0, const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;bounds1)</td></tr>
<tr class="memdesc:a44d062e9354cd14001f47cd01e82b93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if bounds0 and bounds1 represent the same bounds.  <a href="#a44d062e9354cd14001f47cd01e82b93a">More...</a><br /></td></tr>
<tr class="separator:a44d062e9354cd14001f47cd01e82b93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e35493cbdbaecbf87027d1b3474a5b8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e35493cbdbaecbf87027d1b3474a5b8">vars_to_strings</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a9e35493cbdbaecbf87027d1b3474a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of variable names.  <a href="#a9e35493cbdbaecbf87027d1b3474a5b8">More...</a><br /></td></tr>
<tr class="separator:a9e35493cbdbaecbf87027d1b3474a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c20a455c5f2aed48623d012438b99d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a96c20a455c5f2aed48623d012438b99d">extract_rdom</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a96c20a455c5f2aed48623d012438b99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reduction domain used by expr.  <a href="#a96c20a455c5f2aed48623d012438b99d">More...</a><br /></td></tr>
<tr class="separator:a96c20a455c5f2aed48623d012438b99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c553025a28a2d63ed43f8875bf4c18"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab3c553025a28a2d63ed43f8875bf4c18">solve_inverse</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const std::string &amp;new_var, const std::string &amp;var)</td></tr>
<tr class="memdesc:ab3c553025a28a2d63ed43f8875bf4c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">expr is new_var == f(var), solve for var == g(new_var) if multiple new_var correponds to same var, introduce a <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a>  <a href="#ab3c553025a28a2d63ed43f8875bf4c18">More...</a><br /></td></tr>
<tr class="separator:ab3c553025a28a2d63ed43f8875bf4c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa387850d541b7adbe48dffdcc68e1abf"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_buffer_info.html">BufferInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa387850d541b7adbe48dffdcc68e1abf">find_buffer_calls</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;func)</td></tr>
<tr class="separator:aa387850d541b7adbe48dffdcc68e1abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fde1293038bd9c9f0dddde5afdccca"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac4fde1293038bd9c9f0dddde5afdccca">find_implicit_variables</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:ac4fde1293038bd9c9f0dddde5afdccca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all implicit variables in expr.  <a href="#ac4fde1293038bd9c9f0dddde5afdccca">More...</a><br /></td></tr>
<tr class="separator:ac4fde1293038bd9c9f0dddde5afdccca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7c0a6c9d1ffb171d4343876021f604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aea7c0a6c9d1ffb171d4343876021f604">substitute_rdom_predicate</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aea7c0a6c9d1ffb171d4343876021f604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the variable.  <a href="#aea7c0a6c9d1ffb171d4343876021f604">More...</a><br /></td></tr>
<tr class="separator:aea7c0a6c9d1ffb171d4343876021f604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b228248e212d4e140a3b7499f65a8c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b228248e212d4e140a3b7499f65a8c4">is_calling_function</a> (const std::string &amp;func_name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;let_var_mapping)</td></tr>
<tr class="memdesc:a4b228248e212d4e140a3b7499f65a8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if expr contains call to func_name.  <a href="#a4b228248e212d4e140a3b7499f65a8c4">More...</a><br /></td></tr>
<tr class="separator:a4b228248e212d4e140a3b7499f65a8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1be017ee388aad7a1cb19fa653e300"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#add1be017ee388aad7a1cb19fa653e300">is_calling_function</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;let_var_mapping)</td></tr>
<tr class="memdesc:add1be017ee388aad7a1cb19fa653e300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if expr depends on any function or buffer.  <a href="#add1be017ee388aad7a1cb19fa653e300">More...</a><br /></td></tr>
<tr class="separator:add1be017ee388aad7a1cb19fa653e300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f206e59b95e0f061e7bc235f1759e91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1f206e59b95e0f061e7bc235f1759e91">make_device_interface_call</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api)</td></tr>
<tr class="memdesc:a1f206e59b95e0f061e7bc235f1759e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> which evaluates to the device interface for the given device api at runtime.  <a href="#a1f206e59b95e0f061e7bc235f1759e91">More...</a><br /></td></tr>
<tr class="separator:a1f206e59b95e0f061e7bc235f1759e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aedffca433bdfab639e4956779040e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5aedffca433bdfab639e4956779040e6">inject_early_frees</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a5aedffca433bdfab639e4956779040e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation.  <a href="#a5aedffca433bdfab639e4956779040e6">More...</a><br /></td></tr>
<tr class="separator:a5aedffca433bdfab639e4956779040e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0747a9e54d0da5a37c1530162121942f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0747a9e54d0da5a37c1530162121942f">eliminated_bool_type</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> bool_type, <a class="el" href="struct_halide_1_1_type.html">Type</a> other_type)</td></tr>
<tr class="memdesc:a0747a9e54d0da5a37c1530162121942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a type is a boolean vector, find the type that it has been changed to by eliminate_bool_vectors.  <a href="#a0747a9e54d0da5a37c1530162121942f">More...</a><br /></td></tr>
<tr class="separator:a0747a9e54d0da5a37c1530162121942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41efaa6fd3f0ef81666337a4ca0aef9c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a41efaa6fd3f0ef81666337a4ca0aef9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a41efaa6fd3f0ef81666337a4ca0aef9c">ref_count&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *t)</td></tr>
<tr class="separator:a41efaa6fd3f0ef81666337a4ca0aef9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d80243a2f3de47f613df12b48475c3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad3d80243a2f3de47f613df12b48475c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad3d80243a2f3de47f613df12b48475c3">destroy&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *t)</td></tr>
<tr class="separator:ad3d80243a2f3de47f613df12b48475c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29840c52385c687d17608300c94a0ab"><td class="memTemplParams" colspan="2">template&lt;typename StmtOrExpr , typename T &gt; </td></tr>
<tr class="memitem:af29840c52385c687d17608300c94a0ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af29840c52385c687d17608300c94a0ab">stmt_or_expr_uses_vars</a> (StmtOrExpr e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:af29840c52385c687d17608300c94a0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a statement or expression references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#af29840c52385c687d17608300c94a0ab">More...</a><br /></td></tr>
<tr class="separator:af29840c52385c687d17608300c94a0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaade6cc73ce3cd9902f445c135a0226d"><td class="memTemplParams" colspan="2">template&lt;typename StmtOrExpr &gt; </td></tr>
<tr class="memitem:aaade6cc73ce3cd9902f445c135a0226d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaade6cc73ce3cd9902f445c135a0226d">stmt_or_expr_uses_var</a> (StmtOrExpr e, const std::string &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:aaade6cc73ce3cd9902f445c135a0226d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a statement or expression references the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#aaade6cc73ce3cd9902f445c135a0226d">More...</a><br /></td></tr>
<tr class="separator:aaade6cc73ce3cd9902f445c135a0226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f21194a1d0e54add9a15a79eb889dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa5f21194a1d0e54add9a15a79eb889dd">expr_uses_var</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:aa5f21194a1d0e54add9a15a79eb889dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an expression references the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#aa5f21194a1d0e54add9a15a79eb889dd">More...</a><br /></td></tr>
<tr class="separator:aa5f21194a1d0e54add9a15a79eb889dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f70cf57af5925647346a8e1f3a8268"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac7f70cf57af5925647346a8e1f3a8268">stmt_uses_var</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt, const std::string &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:ac7f70cf57af5925647346a8e1f3a8268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a statement references the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#ac7f70cf57af5925647346a8e1f3a8268">More...</a><br /></td></tr>
<tr class="separator:ac7f70cf57af5925647346a8e1f3a8268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bc2cef7dff2305a29dc5512a7542da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9bc2cef7dff2305a29dc5512a7542da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af9bc2cef7dff2305a29dc5512a7542da">expr_uses_vars</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:af9bc2cef7dff2305a29dc5512a7542da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an expression references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#af9bc2cef7dff2305a29dc5512a7542da">More...</a><br /></td></tr>
<tr class="separator:af9bc2cef7dff2305a29dc5512a7542da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69aa39cfbbd5a1aead3e742c4fc0048a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69aa39cfbbd5a1aead3e742c4fc0048a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a69aa39cfbbd5a1aead3e742c4fc0048a">stmt_uses_vars</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a69aa39cfbbd5a1aead3e742c4fc0048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a statement references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#a69aa39cfbbd5a1aead3e742c4fc0048a">More...</a><br /></td></tr>
<tr class="separator:a69aa39cfbbd5a1aead3e742c4fc0048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b42e90ad180f1254cdd3be0ae7be89"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a16b42e90ad180f1254cdd3be0ae7be89">find_direct_calls</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:a16b42e90ad180f1254cdd3be0ae7be89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> extents.  <a href="#a16b42e90ad180f1254cdd3be0ae7be89">More...</a><br /></td></tr>
<tr class="separator:a16b42e90ad180f1254cdd3be0ae7be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a770da2a7374eb2a8ac60f5c9d90b88ad">find_transitive_calls</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, or indirectly in those functions' definitions, recursively.  <a href="#a770da2a7374eb2a8ac60f5c9d90b88ad">More...</a><br /></td></tr>
<tr class="separator:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896238d54e6f7d94171698d1c4296b97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a896238d54e6f7d94171698d1c4296b97">populate_environment</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a896238d54e6f7d94171698d1c4296b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all Functions transitively referenced by f in any way and add them to the given map.  <a href="#a896238d54e6f7d94171698d1c4296b97">More...</a><br /></td></tr>
<tr class="separator:a896238d54e6f7d94171698d1c4296b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memTemplParams" colspan="2">template&lt;typename Last &gt; </td></tr>
<tr class="memitem:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b98bf6f8f3475caaa691d7884a31d45">check_types</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;t, int idx)</td></tr>
<tr class="separator:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec0560d55ceb7384483f00da38ad73f"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest&gt; </td></tr>
<tr class="memitem:abec0560d55ceb7384483f00da38ad73f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abec0560d55ceb7384483f00da38ad73f">check_types</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;t, int idx)</td></tr>
<tr class="separator:abec0560d55ceb7384483f00da38ad73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bce2836846aa0286859b005b6aa015"><td class="memTemplParams" colspan="2">template&lt;typename Last &gt; </td></tr>
<tr class="memitem:a32bce2836846aa0286859b005b6aa015"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a32bce2836846aa0286859b005b6aa015">assign_results</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;r, int idx, Last last)</td></tr>
<tr class="separator:a32bce2836846aa0286859b005b6aa015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc822256984ddc07c031b230ce2b8ae"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest&gt; </td></tr>
<tr class="memitem:acdc822256984ddc07c031b230ce2b8ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acdc822256984ddc07c031b230ce2b8ae">assign_results</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;r, int idx, First first, Second second, Rest &amp;&amp;...rest)</td></tr>
<tr class="separator:acdc822256984ddc07c031b230ce2b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9bfb55aa0058e51d72037fde785fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1f9bfb55aa0058e51d72037fde785fb0">schedule_scalar</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f)</td></tr>
<tr class="separator:a1f9bfb55aa0058e51d72037fde785fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad946e0645ead551baee06d6c39e6552"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;, std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aad946e0645ead551baee06d6c39e6552">deep_copy</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:aad946e0645ead551baee06d6c39e6552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy an entire <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> DAG.  <a href="#aad946e0645ead551baee06d6c39e6552">More...</a><br /></td></tr>
<tr class="separator:aad946e0645ead551baee06d6c39e6552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c3eca91038227e115e5440d687c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a318c3eca91038227e115e5440d687c43">zero_gpu_loop_mins</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a318c3eca91038227e115e5440d687c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite all GPU loops to have a min of zero.  <a href="#a318c3eca91038227e115e5440d687c43">More...</a><br /></td></tr>
<tr class="separator:a318c3eca91038227e115e5440d687c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0081752824625e87b5e95bfae979499f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0081752824625e87b5e95bfae979499f">fuse_gpu_thread_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a0081752824625e87b5e95bfae979499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s GPGPU IR to the OpenCL/CUDA/Metal model.  <a href="#a0081752824625e87b5e95bfae979499f">More...</a><br /></td></tr>
<tr class="separator:a0081752824625e87b5e95bfae979499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a15fc4880c65ae27434a924540a07e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a56a15fc4880c65ae27434a924540a07e">fuzz_float_stores</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a56a15fc4880c65ae27434a924540a07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">On every store of a floating point value, mask off the least-significant-bit of the mantissa.  <a href="#a56a15fc4880c65ae27434a924540a07e">More...</a><br /></td></tr>
<tr class="separator:a56a15fc4880c65ae27434a924540a07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4be7daed1a8c6cd914be946f22ea4df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac4be7daed1a8c6cd914be946f22ea4df">generator_test</a> ()</td></tr>
<tr class="separator:ac4be7daed1a8c6cd914be946f22ea4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2672948a0299d09a067ec4dbb862723"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa2672948a0299d09a067ec4dbb862723">parameter_constraints</a> (const <a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a> &amp;p)</td></tr>
<tr class="separator:aa2672948a0299d09a067ec4dbb862723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b54f450e1cd03c240743907e45487ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b54f450e1cd03c240743907e45487ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9b54f450e1cd03c240743907e45487ce">enum_to_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const T &amp;t)</td></tr>
<tr class="separator:a9b54f450e1cd03c240743907e45487ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afd2308d89d4a9b9eef0803e92c383b0c">enum_from_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const std::string &amp;s)</td></tr>
<tr class="separator:afd2308d89d4a9b9eef0803e92c383b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb90b52661557ff81407bc45cbdf3e6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aebb90b52661557ff81407bc45cbdf3e6">get_halide_type_enum_map</a> ()</td></tr>
<tr class="separator:aebb90b52661557ff81407bc45cbdf3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc7c793b324e02e15a109f1e8af548c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2cc7c793b324e02e15a109f1e8af548c">halide_type_to_enum_string</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t)</td></tr>
<tr class="separator:a2cc7c793b324e02e15a109f1e8af548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600136fc73541f81f75ee07095a62025"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a600136fc73541f81f75ee07095a62025">halide_type_to_c_source</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t)</td></tr>
<tr class="separator:a600136fc73541f81f75ee07095a62025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8f71298de4ece7dc2e59ae811c3fd2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e8f71298de4ece7dc2e59ae811c3fd2">halide_type_to_c_type</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t)</td></tr>
<tr class="separator:a9e8f71298de4ece7dc2e59ae811c3fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032a99a32ca261c475b4335ece416dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd">generate_filter_main</a> (int argc, char **argv, std::ostream &amp;cerr)</td></tr>
<tr class="memdesc:ad032a99a32ca261c475b4335ece416dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#aab480390a9681797693f2c8c9b867013">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation.  <a href="#ad032a99a32ca261c475b4335ece416dd">More...</a><br /></td></tr>
<tr class="separator:ad032a99a32ca261c475b4335ece416dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae47fa4b8f49636c214b214f5d0f4ed34">parse_scalar</a> (const std::string &amp;value)</td></tr>
<tr class="separator:ae47fa4b8f49636c214b214f5d0f4ed34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7682395f90f7229826df771f8c286fac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7682395f90f7229826df771f8c286fac">parse_halide_type_list</a> (const std::string &amp;types)</td></tr>
<tr class="separator:a7682395f90f7229826df771f8c286fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8696c48228f0cb335255ae46954909e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8696c48228f0cb335255ae46954909e1">inject_hexagon_rpc</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;host_target, <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module)</td></tr>
<tr class="memdesc:a8696c48228f0cb335255ae46954909e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull loops marked with the Hexagon device API to a separate module, and call them through the Hexagon host runtime module.  <a href="#a8696c48228f0cb335255ae46954909e1">More...</a><br /></td></tr>
<tr class="separator:a8696c48228f0cb335255ae46954909e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a0c1dd9c3f33e07eb6df7b59850286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a55a0c1dd9c3f33e07eb6df7b59850286">compile_module_to_hexagon_shared_object</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;device_code)</td></tr>
<tr class="separator:a55a0c1dd9c3f33e07eb6df7b59850286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23028986d4f21dce50037af81288d511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a23028986d4f21dce50037af81288d511">optimize_hexagon_shuffles</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, int lut_alignment)</td></tr>
<tr class="memdesc:a23028986d4f21dce50037af81288d511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace indirect and other loads with simple loads + vlut calls.  <a href="#a23028986d4f21dce50037af81288d511">More...</a><br /></td></tr>
<tr class="separator:a23028986d4f21dce50037af81288d511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a253a99e9c356e4f91110a986d33cea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7a253a99e9c356e4f91110a986d33cea">vtmpy_generator</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a7a253a99e9c356e4f91110a986d33cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate vtmpy instruction if possible.  <a href="#a7a253a99e9c356e4f91110a986d33cea">More...</a><br /></td></tr>
<tr class="separator:a7a253a99e9c356e4f91110a986d33cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00dade7d363c80cd56af5987be8c93d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae00dade7d363c80cd56af5987be8c93d">optimize_hexagon_instructions</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, <a class="el" href="struct_halide_1_1_target.html">Target</a> t, <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment_info)</td></tr>
<tr class="memdesc:ae00dade7d363c80cd56af5987be8c93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hexagon deinterleaves when performing widening operations, and interleaves when performing narrowing operations.  <a href="#ae00dade7d363c80cd56af5987be8c93d">More...</a><br /></td></tr>
<tr class="separator:ae00dade7d363c80cd56af5987be8c93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528f74485df2d7be5b5fc9e2c8bc51b5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_inferred_argument.html">InferredArgument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a528f74485df2d7be5b5fc9e2c8bc51b5">infer_arguments</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> body, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="separator:a528f74485df2d7be5b5fc9e2c8bc51b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f932b31fe791a7b2002b829c8e5364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a50f932b31fe791a7b2002b829c8e5364">call_extern_and_assert</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="memdesc:a50f932b31fe791a7b2002b829c8e5364"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to call an extern function, and assert that it returns 0.  <a href="#a50f932b31fe791a7b2002b829c8e5364">More...</a><br /></td></tr>
<tr class="separator:a50f932b31fe791a7b2002b829c8e5364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9fa15ced2f13142e6c4b5e5f4649aa15">inject_host_dev_buffer_copies</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject calls to halide_device_malloc, halide_copy_to_device, and halide_copy_to_host as needed.  <a href="#a9fa15ced2f13142e6c4b5e5f4649aa15">More...</a><br /></td></tr>
<tr class="separator:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94843d09c24cd65c12aa022e0ae3bb70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94843d09c24cd65c12aa022e0ae3bb70">inject_opengl_intrinsics</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a94843d09c24cd65c12aa022e0ae3bb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for kernel for loops and turn loads and stores inside the loops into OpenGL texture load and store intrinsics.  <a href="#a94843d09c24cd65c12aa022e0ae3bb70">More...</a><br /></td></tr>
<tr class="separator:a94843d09c24cd65c12aa022e0ae3bb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6883343b90964967cb0bafb2551f5c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab6883343b90964967cb0bafb2551f5c3">validate_schedule_inlined_function</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:ab6883343b90964967cb0bafb2551f5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the schedule of an inlined function is legal, throwing an error if it is not.  <a href="#ab6883343b90964967cb0bafb2551f5c3">More...</a><br /></td></tr>
<tr class="separator:ab6883343b90964967cb0bafb2551f5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad703cfb8d8fe0305a282b71a8824303a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad703cfb8d8fe0305a282b71a8824303a">interval_test</a> ()</td></tr>
<tr class="separator:ad703cfb8d8fe0305a282b71a8824303a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59065f04bcf4e664007d95affa7ce3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac59065f04bcf4e664007d95affa7ce3f">ir_equality_test</a> ()</td></tr>
<tr class="separator:ac59065f04bcf4e664007d95affa7ce3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22936be5f74cc50d73a4e478bd9271e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af22936be5f74cc50d73a4e478bd9271e">expr_match</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> pattern, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:af22936be5f74cc50d73a4e478bd9271e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument.  <a href="#af22936be5f74cc50d73a4e478bd9271e">More...</a><br /></td></tr>
<tr class="separator:af22936be5f74cc50d73a4e478bd9271e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cc40f5fe9cc4d0ba0bf37b5550ad01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a90cc40f5fe9cc4d0ba0bf37b5550ad01">expr_match</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> pattern, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a90cc40f5fe9cc4d0ba0bf37b5550ad01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables are matched consistently.  <a href="#a90cc40f5fe9cc4d0ba0bf37b5550ad01">More...</a><br /></td></tr>
<tr class="separator:a90cc40f5fe9cc4d0ba0bf37b5550ad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1eed932bc0eb3a15edcb20795bfb8c2f">expr_match_test</a> ()</td></tr>
<tr class="separator:a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11d0eaaf5222de9d1151bf81479beb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af11d0eaaf5222de9d1151bf81479beb9">is_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:af11d0eaaf5222de9d1151bf81479beb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants. ">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node. ">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="#af11d0eaaf5222de9d1151bf81479beb9">More...</a><br /></td></tr>
<tr class="separator:af11d0eaaf5222de9d1151bf81479beb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0438766d0040aa39c5f420f1a92b01b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad0438766d0040aa39c5f420f1a92b01b">is_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> v)</td></tr>
<tr class="memdesc:ad0438766d0040aa39c5f420f1a92b01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="#ad0438766d0040aa39c5f420f1a92b01b">More...</a><br /></td></tr>
<tr class="separator:ad0438766d0040aa39c5f420f1a92b01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f803a9899cc2d96a93179dba4bf21f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a98f803a9899cc2d96a93179dba4bf21f">as_const_int</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a98f803a9899cc2d96a93179dba4bf21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, return a pointer to its value.  <a href="#a98f803a9899cc2d96a93179dba4bf21f">More...</a><br /></td></tr>
<tr class="separator:a98f803a9899cc2d96a93179dba4bf21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c472a5cc4013b179510625b02bf6d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae2c472a5cc4013b179510625b02bf6d6">as_const_uint</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:ae2c472a5cc4013b179510625b02bf6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a>, return a pointer to its value.  <a href="#ae2c472a5cc4013b179510625b02bf6d6">More...</a><br /></td></tr>
<tr class="separator:ae2c472a5cc4013b179510625b02bf6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6252d95fc57aad0465caf882eded56bb"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6252d95fc57aad0465caf882eded56bb">as_const_float</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a6252d95fc57aad0465caf882eded56bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, return a pointer to its value.  <a href="#a6252d95fc57aad0465caf882eded56bb">More...</a><br /></td></tr>
<tr class="separator:a6252d95fc57aad0465caf882eded56bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f2b30c213250c3ba20c4d211f5b00f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa5f2b30c213250c3ba20c4d211f5b00f">is_const_power_of_two_integer</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e, int *bits)</td></tr>
<tr class="memdesc:aa5f2b30c213250c3ba20c4d211f5b00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <a href="#aa5f2b30c213250c3ba20c4d211f5b00f">More...</a><br /></td></tr>
<tr class="separator:aa5f2b30c213250c3ba20c4d211f5b00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f26b6233cff17bdbf097bfe981e096c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5f26b6233cff17bdbf097bfe981e096c">is_positive_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a5f26b6233cff17bdbf097bfe981e096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <a href="#a5f26b6233cff17bdbf097bfe981e096c">More...</a><br /></td></tr>
<tr class="separator:a5f26b6233cff17bdbf097bfe981e096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0e57c1aaa1719ed42fac6dc6661ebe90">is_negative_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <a href="#a0e57c1aaa1719ed42fac6dc6661ebe90">More...</a><br /></td></tr>
<tr class="separator:a0e57c1aaa1719ed42fac6dc6661ebe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3204e449a3ad9f0b1377539764da59a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3204e449a3ad9f0b1377539764da59a6">is_negative_negatable_const</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a3204e449a3ad9f0b1377539764da59a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) and is its negative value representable.  <a href="#a3204e449a3ad9f0b1377539764da59a6">More...</a><br /></td></tr>
<tr class="separator:a3204e449a3ad9f0b1377539764da59a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb4bb1c7164222794e270f58c428eb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0eb4bb1c7164222794e270f58c428eb7">is_undef</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a0eb4bb1c7164222794e270f58c428eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an undef.  <a href="#a0eb4bb1c7164222794e270f58c428eb7">More...</a><br /></td></tr>
<tr class="separator:a0eb4bb1c7164222794e270f58c428eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417121e0d1b13f7f5a864091388ca048"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a417121e0d1b13f7f5a864091388ca048">is_zero</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a417121e0d1b13f7f5a864091388ca048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <a href="#a417121e0d1b13f7f5a864091388ca048">More...</a><br /></td></tr>
<tr class="separator:a417121e0d1b13f7f5a864091388ca048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83157c92372f583e993d653d27b967a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a83157c92372f583e993d653d27b967a1">is_one</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a83157c92372f583e993d653d27b967a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <a href="#a83157c92372f583e993d653d27b967a1">More...</a><br /></td></tr>
<tr class="separator:a83157c92372f583e993d653d27b967a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e4631b054fafe0883781e00b77a5ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a32e4631b054fafe0883781e00b77a5ca">is_two</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a32e4631b054fafe0883781e00b77a5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression)  <a href="#a32e4631b054fafe0883781e00b77a5ca">More...</a><br /></td></tr>
<tr class="separator:a32e4631b054fafe0883781e00b77a5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916dccb9f4ad5763ce86721ab3187cfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a916dccb9f4ad5763ce86721ab3187cfc">is_no_op</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;s)</td></tr>
<tr class="memdesc:a916dccb9f4ad5763ce86721ab3187cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> node of a constant)  <a href="#a916dccb9f4ad5763ce86721ab3187cfc">More...</a><br /></td></tr>
<tr class="separator:a916dccb9f4ad5763ce86721ab3187cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8325254f314a3811cc5ebebf4497466d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8325254f314a3811cc5ebebf4497466d">is_pure</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a8325254f314a3811cc5ebebf4497466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the expression 1) Take on the same value no matter where it appears in a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, and 2) Evaluating it has no side-effects.  <a href="#a8325254f314a3811cc5ebebf4497466d">More...</a><br /></td></tr>
<tr class="separator:a8325254f314a3811cc5ebebf4497466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de10096d923cdc0f02582981b718854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2de10096d923cdc0f02582981b718854">check_representable</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a2de10096d923cdc0f02582981b718854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a constant value can be correctly represented as the given type.  <a href="#a2de10096d923cdc0f02582981b718854">More...</a><br /></td></tr>
<tr class="separator:a2de10096d923cdc0f02582981b718854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2aa7992959c35ebe5895999b762b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace2aa7992959c35ebe5895999b762b34">make_bool</a> (bool val, int lanes=1)</td></tr>
<tr class="memdesc:ace2aa7992959c35ebe5895999b762b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <a href="#ace2aa7992959c35ebe5895999b762b34">More...</a><br /></td></tr>
<tr class="separator:ace2aa7992959c35ebe5895999b762b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0e4b9c03c76d9a19a0d7a7de2036f1b6">make_zero</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <a href="#a0e4b9c03c76d9a19a0d7a7de2036f1b6">More...</a><br /></td></tr>
<tr class="separator:a0e4b9c03c76d9a19a0d7a7de2036f1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e5ab6b1524fd81132823c77c35d717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a01e5ab6b1524fd81132823c77c35d717">make_one</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a01e5ab6b1524fd81132823c77c35d717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <a href="#a01e5ab6b1524fd81132823c77c35d717">More...</a><br /></td></tr>
<tr class="separator:a01e5ab6b1524fd81132823c77c35d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bdd8230cefd6bf9f84ac909311d87e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a14bdd8230cefd6bf9f84ac909311d87e">make_two</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a14bdd8230cefd6bf9f84ac909311d87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <a href="#a14bdd8230cefd6bf9f84ac909311d87e">More...</a><br /></td></tr>
<tr class="separator:a14bdd8230cefd6bf9f84ac909311d87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb413640f7f46493733fa33d95ea9fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5fb413640f7f46493733fa33d95ea9fc">const_true</a> (int lanes=1)</td></tr>
<tr class="memdesc:a5fb413640f7f46493733fa33d95ea9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <a href="#a5fb413640f7f46493733fa33d95ea9fc">More...</a><br /></td></tr>
<tr class="separator:a5fb413640f7f46493733fa33d95ea9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94c84e726218144cf4c5d3a08b38f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab94c84e726218144cf4c5d3a08b38f8d">const_false</a> (int lanes=1)</td></tr>
<tr class="memdesc:ab94c84e726218144cf4c5d3a08b38f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <a href="#ab94c84e726218144cf4c5d3a08b38f8d">More...</a><br /></td></tr>
<tr class="separator:ab94c84e726218144cf4c5d3a08b38f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e5b44f4f584318f9065bcf39c75c84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae1e5b44f4f584318f9065bcf39c75c84">lossless_cast</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:ae1e5b44f4f584318f9065bcf39c75c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cast an expression to a smaller type while provably not losing information.  <a href="#ae1e5b44f4f584318f9065bcf39c75c84">More...</a><br /></td></tr>
<tr class="separator:ae1e5b44f4f584318f9065bcf39c75c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365bfad96972abe9e008bb1b601223f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">match_types</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a365bfad96972abe9e008bb1b601223f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <a href="#a365bfad96972abe9e008bb1b601223f9">More...</a><br /></td></tr>
<tr class="separator:a365bfad96972abe9e008bb1b601223f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec662f503947166115071493eaa00780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aec662f503947166115071493eaa00780">raise_to_integer_power</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:aec662f503947166115071493eaa00780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <a href="#aec662f503947166115071493eaa00780">More...</a><br /></td></tr>
<tr class="separator:aec662f503947166115071493eaa00780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839473cf858ba53326b678db072411d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a839473cf858ba53326b678db072411d2">split_into_ands</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;<a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a839473cf858ba53326b678db072411d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs.  <a href="#a839473cf858ba53326b678db072411d2">More...</a><br /></td></tr>
<tr class="separator:a839473cf858ba53326b678db072411d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4093d5c88fc8306429ca00725dbabbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac4093d5c88fc8306429ca00725dbabbd">strided_ramp_base</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int stride=1)</td></tr>
<tr class="memdesc:ac4093d5c88fc8306429ca00725dbabbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">If e is a ramp expression with stride, default 1, return the base, otherwise undefined.  <a href="#ac4093d5c88fc8306429ca00725dbabbd">More...</a><br /></td></tr>
<tr class="separator:ac4093d5c88fc8306429ca00725dbabbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7ed2ca593eca53111eaf753a7fc9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acf7ed2ca593eca53111eaf753a7fc9bf">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:acf7ed2ca593eca53111eaf753a7fc9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7c2f51029190ae224290688b7c4c3b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4d7c2f51029190ae224290688b7c4c3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d7c2f51029190ae224290688b7c4c3b">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args, const char *arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:a4d7c2f51029190ae224290688b7c4c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda140fdf727dfa11f6f3151fc4f7661"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adda140fdf727dfa11f6f3151fc4f7661"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adda140fdf727dfa11f6f3151fc4f7661">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:adda140fdf727dfa11f6f3151fc4f7661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082d3bda0d60128ae127d0879e7e38c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a082d3bda0d60128ae127d0879e7e38c9">memoize_tag_helper</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> result, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;cache_key_values)</td></tr>
<tr class="separator:a082d3bda0d60128ae127d0879e7e38c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fe20393021d437778c0587afbc448d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a83fe20393021d437778c0587afbc448d">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a> &amp;)</td></tr>
<tr class="memdesc:a83fe20393021d437778c0587afbc448d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide associative pattern on an output stream (such as std::cout) in a human-readable form.  <a href="#a83fe20393021d437778c0587afbc448d">More...</a><br /></td></tr>
<tr class="separator:a83fe20393021d437778c0587afbc448d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3b530e690cbe977d889e0931f8933d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4e3b530e690cbe977d889e0931f8933d">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a> &amp;)</td></tr>
<tr class="memdesc:a4e3b530e690cbe977d889e0931f8933d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide associative op on an output stream (such as std::cout) in a human-readable form.  <a href="#a4e3b530e690cbe977d889e0931f8933d">More...</a><br /></td></tr>
<tr class="separator:a4e3b530e690cbe977d889e0931f8933d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cfea8acb4f311a9365e26a8f7de08f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a10cfea8acb4f311a9365e26a8f7de08f">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> &amp;)</td></tr>
<tr class="memdesc:a10cfea8acb4f311a9365e26a8f7de08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide for loop type (vectorized, serial, etc) in a human readable form.  <a href="#a10cfea8acb4f311a9365e26a8f7de08f">More...</a><br /></td></tr>
<tr class="separator:a10cfea8acb4f311a9365e26a8f7de08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1f893faca900eef051b7c0c182fde5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6e1f893faca900eef051b7c0c182fde5">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> &amp;)</td></tr>
<tr class="memdesc:a6e1f893faca900eef051b7c0c182fde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide name mangling value in a human readable format.  <a href="#a6e1f893faca900eef051b7c0c182fde5">More...</a><br /></td></tr>
<tr class="separator:a6e1f893faca900eef051b7c0c182fde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f77f82c9290637ca0b5497f73a8f555"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6f77f82c9290637ca0b5497f73a8f555">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> &amp;)</td></tr>
<tr class="memdesc:a6f77f82c9290637ca0b5497f73a8f555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide linkage value in a human readable format.  <a href="#a6f77f82c9290637ca0b5497f73a8f555">More...</a><br /></td></tr>
<tr class="separator:a6f77f82c9290637ca0b5497f73a8f555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9af6e36531c5c2b17cc031c3d5e241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aea9af6e36531c5c2b17cc031c3d5e241">lower_lerp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> zero_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> one_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> weight)</td></tr>
<tr class="memdesc:aea9af6e36531c5c2b17cc031c3d5e241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> IR that computes a lerp.  <a href="#aea9af6e36531c5c2b17cc031c3d5e241">More...</a><br /></td></tr>
<tr class="separator:aea9af6e36531c5c2b17cc031c3d5e241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d5d64835b9903431e1ae1477b15f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a58d5d64835b9903431e1ae1477b15f64">loop_invariant_code_motion</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:a58d5d64835b9903431e1ae1477b15f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist loop-invariants out of inner loops.  <a href="#a58d5d64835b9903431e1ae1477b15f64">More...</a><br /></td></tr>
<tr class="separator:a58d5d64835b9903431e1ae1477b15f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9d2c57ff18ef709b6a4e444f4af5ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e9d2c57ff18ef709b6a4e444f4af5ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6e9d2c57ff18ef709b6a4e444f4af5ff">iterator_to_pointer</a> (T iter) -&gt; decltype(&amp;*std::declval&lt; T &gt;())</td></tr>
<tr class="separator:a6e9d2c57ff18ef709b6a4e444f4af5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496ad11988df981c987a2557c3cd2d8c"><td class="memItemLeft" align="right" valign="top">llvm::Triple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a496ad11988df981c987a2557c3cd2d8c">get_triple_for_target</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a496ad11988df981c987a2557c3cd2d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the llvm::Triple that corresponds to the given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a496ad11988df981c987a2557c3cd2d8c">More...</a><br /></td></tr>
<tr class="separator:a496ad11988df981c987a2557c3cd2d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b2ac324e660b73262abdb4b0643451"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a30b2ac324e660b73262abdb4b0643451">get_initial_module_for_target</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *, bool for_shared_jit_runtime=false, bool just_gpu=false)</td></tr>
<tr class="memdesc:a30b2ac324e660b73262abdb4b0643451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for a given target.  <a href="#a30b2ac324e660b73262abdb4b0643451">More...</a><br /></td></tr>
<tr class="separator:a30b2ac324e660b73262abdb4b0643451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e77b70f4bfb715115d8c3a690b2faa0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e77b70f4bfb715115d8c3a690b2faa0">get_initial_module_for_ptx_device</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *c)</td></tr>
<tr class="memdesc:a9e77b70f4bfb715115d8c3a690b2faa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for ptx device.  <a href="#a9e77b70f4bfb715115d8c3a690b2faa0">More...</a><br /></td></tr>
<tr class="separator:a9e77b70f4bfb715115d8c3a690b2faa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c2253813b438bcb811778d84b98e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af5c2253813b438bcb811778d84b98e94">add_bitcode_to_module</a> (llvm::LLVMContext *context, llvm::Module &amp;module, const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> &gt; &amp;bitcode, const std::string &amp;name)</td></tr>
<tr class="memdesc:af5c2253813b438bcb811778d84b98e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link a block of llvm bitcode into an llvm module.  <a href="#af5c2253813b438bcb811778d84b98e94">More...</a><br /></td></tr>
<tr class="separator:af5c2253813b438bcb811778d84b98e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1fc91c3863b2f3b6afe3902a717ff68b">loop_carry</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, int max_carried_values=8)</td></tr>
<tr class="memdesc:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reuse loads done on previous loop iterations by stashing them in induction variables instead of redoing the load.  <a href="#a1fc91c3863b2f3b6afe3902a717ff68b">More...</a><br /></td></tr>
<tr class="separator:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599a108a4c15695c0530287344e2fbac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_module.html">Module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a599a108a4c15695c0530287344e2fbac">lower</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;output_funcs, const std::string &amp;pipeline_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;args, const <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> linkage_type, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a> * &gt; &amp;custom_passes=std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a> * &gt;())</td></tr>
<tr class="memdesc:a599a108a4c15695c0530287344e2fbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of scheduled halide functions, create a <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> that evaluates it.  <a href="#a599a108a4c15695c0530287344e2fbac">More...</a><br /></td></tr>
<tr class="separator:a599a108a4c15695c0530287344e2fbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3579ee621d6531a4d635eb766640a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa3579ee621d6531a4d635eb766640a9c">lower_main_stmt</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;output_funcs, const std::string &amp;pipeline_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a> * &gt; &amp;custom_passes=std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a> * &gt;())</td></tr>
<tr class="memdesc:aa3579ee621d6531a4d635eb766640a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a halide function with a schedule, create a statement that evaluates it.  <a href="#aa3579ee621d6531a4d635eb766640a9c">More...</a><br /></td></tr>
<tr class="separator:aa3579ee621d6531a4d635eb766640a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3bfe43201bab68cf4820993fe1469b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d3bfe43201bab68cf4820993fe1469b">lower_test</a> ()</td></tr>
<tr class="separator:a4d3bfe43201bab68cf4820993fe1469b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa573630ec30c63bc99cd46a4217cbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7fa573630ec30c63bc99cd46a4217cbb">lower_warp_shuffles</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a7fa573630ec30c63bc99cd46a4217cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite access to things stored outside the loop over GPU lanes to use nvidia's warp shuffle instructions.  <a href="#a7fa573630ec30c63bc99cd46a4217cbb">More...</a><br /></td></tr>
<tr class="separator:a7fa573630ec30c63bc99cd46a4217cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a57c1db8b5f97b8003a5271907bfdda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261">llvm::Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6a57c1db8b5f97b8003a5271907bfdda">define_matlab_wrapper</a> (llvm::Module *module, <a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261">llvm::Function</a> *pipeline_argv_wrapper, <a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261">llvm::Function</a> *metadata_getter)</td></tr>
<tr class="memdesc:a6a57c1db8b5f97b8003a5271907bfdda"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> a mexFunction wrapper definition to the module, calling the function with the name pipeline_name.  <a href="#a6a57c1db8b5f97b8003a5271907bfdda">More...</a><br /></td></tr>
<tr class="separator:a6a57c1db8b5f97b8003a5271907bfdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585e65b645868795c02e73c853404321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a585e65b645868795c02e73c853404321">inject_memoization</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::string &amp;name, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="memdesc:a585e65b645868795c02e73c853404321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform pipeline calls for Funcs scheduled with memoize to do a lookup call to the runtime cache implementation, and if there is a miss, compute the results and call the runtime to store it back to the cache.  <a href="#a585e65b645868795c02e73c853404321">More...</a><br /></td></tr>
<tr class="separator:a585e65b645868795c02e73c853404321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb0d4310fbae915041f61f46dc96677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0cb0d4310fbae915041f61f46dc96677">rewrite_memoized_allocations</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a0cb0d4310fbae915041f61f46dc96677"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called after Storage Flattening has added Allocation IR nodes.  <a href="#a0cb0d4310fbae915041f61f46dc96677">More...</a><br /></td></tr>
<tr class="separator:a0cb0d4310fbae915041f61f46dc96677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552b2c330fdb1275badc27cc1e92cd6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a552b2c330fdb1275badc27cc1e92cd6a">modulus_remainder</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a552b2c330fdb1275badc27cc1e92cd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant.  <a href="#a552b2c330fdb1275badc27cc1e92cd6a">More...</a><br /></td></tr>
<tr class="separator:a552b2c330fdb1275badc27cc1e92cd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8489fb5b4449835f26313a57e856c4b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8489fb5b4449835f26313a57e856c4b3">modulus_remainder</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:a8489fb5b4449835f26313a57e856c4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder:  <a href="#a8489fb5b4449835f26313a57e856c4b3">More...</a><br /></td></tr>
<tr class="separator:a8489fb5b4449835f26313a57e856c4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789149daec96e933f8758f71f8474dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a789149daec96e933f8758f71f8474dd6">modulus_remainder_test</a> ()</td></tr>
<tr class="separator:a789149daec96e933f8758f71f8474dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3383c51a3621854507bf149283901fd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3383c51a3621854507bf149283901fd8">gcd</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>)</td></tr>
<tr class="memdesc:a3383c51a3621854507bf149283901fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greatest common divisor of two integers.  <a href="#a3383c51a3621854507bf149283901fd8">More...</a><br /></td></tr>
<tr class="separator:a3383c51a3621854507bf149283901fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6d5d650979fec41ce02d02ac0b7c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aea6d5d650979fec41ce02d02ac0b7c20">lcm</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>)</td></tr>
<tr class="memdesc:aea6d5d650979fec41ce02d02ac0b7c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The least common multiple of two integers.  <a href="#aea6d5d650979fec41ce02d02ac0b7c20">More...</a><br /></td></tr>
<tr class="separator:aea6d5d650979fec41ce02d02ac0b7c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ee7edbeb93353d1cb6b1f6cbfbe525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a40ee7edbeb93353d1cb6b1f6cbfbe525">is_monotonic</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;var)</td></tr>
<tr class="separator:a40ee7edbeb93353d1cb6b1f6cbfbe525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de4b237eafb498206aa2eb0c94b4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af6de4b237eafb498206aa2eb0c94b4ad">is_monotonic_test</a> ()</td></tr>
<tr class="separator:af6de4b237eafb498206aa2eb0c94b4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a87590be371b78913eaab20e563f335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9a87590be371b78913eaab20e563f335">can_parallelize_rvar</a> (const std::string &amp;rvar, const std::string &amp;func, const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;r)</td></tr>
<tr class="memdesc:a9a87590be371b78913eaab20e563f335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> can prove that it is safe to parallelize an update definition across a specific variable.  <a href="#a9a87590be371b78913eaab20e563f335">More...</a><br /></td></tr>
<tr class="separator:a9a87590be371b78913eaab20e563f335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce66817377fbb1918bbe7510ab47b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0ce66817377fbb1918bbe7510ab47b29">check_call_arg_types</a> (const std::string &amp;name, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; *args, int dims)</td></tr>
<tr class="memdesc:a0ce66817377fbb1918bbe7510ab47b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate arguments to a call to a func, image or imageparam.  <a href="#a0ce66817377fbb1918bbe7510ab47b29">More...</a><br /></td></tr>
<tr class="separator:a0ce66817377fbb1918bbe7510ab47b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270c212209434d22a1d368e561bc75a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a270c212209434d22a1d368e561bc75a0">has_likely_tag</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a270c212209434d22a1d368e561bc75a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if an expression uses a likely tag.  <a href="#a270c212209434d22a1d368e561bc75a0">More...</a><br /></td></tr>
<tr class="separator:a270c212209434d22a1d368e561bc75a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d00fe3db9030d30827191d78c36fda5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d00fe3db9030d30827191d78c36fda5">partition_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a3d00fe3db9030d30827191d78c36fda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions loop bodies into a prologue, a steady state, and an epilogue.  <a href="#a3d00fe3db9030d30827191d78c36fda5">More...</a><br /></td></tr>
<tr class="separator:a3d00fe3db9030d30827191d78c36fda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dd66428062b0d413dec72214c26f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae9dd66428062b0d413dec72214c26f5e">inject_placeholder_prefetch</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::string &amp;prefix, const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a> &gt; &amp;prefetches)</td></tr>
<tr class="memdesc:ae9dd66428062b0d413dec72214c26f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject placeholder prefetches to 's'.  <a href="#ae9dd66428062b0d413dec72214c26f5e">More...</a><br /></td></tr>
<tr class="separator:ae9dd66428062b0d413dec72214c26f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00dbff02860c1622c6e4d1fba8ac01e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a00dbff02860c1622c6e4d1fba8ac01e3">inject_prefetch</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a00dbff02860c1622c6e4d1fba8ac01e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the actual region to be prefetched and place it to the placholder prefetch.  <a href="#a00dbff02860c1622c6e4d1fba8ac01e3">More...</a><br /></td></tr>
<tr class="separator:a00dbff02860c1622c6e4d1fba8ac01e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cbede92a4cd09354b032a40829a9d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a23cbede92a4cd09354b032a40829a9d1">reduce_prefetch_dimension</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a23cbede92a4cd09354b032a40829a9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a multi-dimensional prefetch into a prefetch of lower dimension (max dimension of the prefetch is specified by target architecture).  <a href="#a23cbede92a4cd09354b032a40829a9d1">More...</a><br /></td></tr>
<tr class="separator:a23cbede92a4cd09354b032a40829a9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35ddfd891459204fae6afbcbdb6bac6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa35ddfd891459204fae6afbcbdb6bac6">print_loop_nest</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;output_funcs)</td></tr>
<tr class="memdesc:aa35ddfd891459204fae6afbcbdb6bac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit some simple pseudocode that shows the structure of the loop nest specified by this pipeline's schedule, and the schedules of the functions it uses.  <a href="#aa35ddfd891459204fae6afbcbdb6bac6">More...</a><br /></td></tr>
<tr class="separator:aa35ddfd891459204fae6afbcbdb6bac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568a0554db6866ee8560c3f599bceadd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a568a0554db6866ee8560c3f599bceadd">inject_profiling</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, std::string)</td></tr>
<tr class="memdesc:a568a0554db6866ee8560c3f599bceadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline insert high-resolution timing into the generated code (via spawning a thread that acts as a sampling profiler); summaries of execution times and counts will be logged at the end.  <a href="#a568a0554db6866ee8560c3f599bceadd">More...</a><br /></td></tr>
<tr class="separator:a568a0554db6866ee8560c3f599bceadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0c1d3ac79fd83cb609d37831253957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#add0c1d3ac79fd83cb609d37831253957">qualify</a> (const std::string &amp;prefix, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value)</td></tr>
<tr class="memdesc:add0c1d3ac79fd83cb609d37831253957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix all variable names in the given expression with the prefix string.  <a href="#add0c1d3ac79fd83cb609d37831253957">More...</a><br /></td></tr>
<tr class="separator:add0c1d3ac79fd83cb609d37831253957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795f343747d7f716a33198907c3e7d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a795f343747d7f716a33198907c3e7d25">random_float</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a795f343747d7f716a33198907c3e7d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random floating-point number between zero and one that varies deterministically based on the input expressions.  <a href="#a795f343747d7f716a33198907c3e7d25">More...</a><br /></td></tr>
<tr class="separator:a795f343747d7f716a33198907c3e7d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e64539c6d89123f6200b919ec28fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae4e64539c6d89123f6200b919ec28fbb">random_int</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ae4e64539c6d89123f6200b919ec28fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers or unsigned integers).  <a href="#ae4e64539c6d89123f6200b919ec28fbb">More...</a><br /></td></tr>
<tr class="separator:ae4e64539c6d89123f6200b919ec28fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f875bf4d528885d68581fbd198bf356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f875bf4d528885d68581fbd198bf356">lower_random</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::vector&lt; std::string &gt; &amp;free_vars, int tag)</td></tr>
<tr class="memdesc:a0f875bf4d528885d68581fbd198bf356"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> calls to random() to IR generated by random_float and random_int.  <a href="#a0f875bf4d528885d68581fbd198bf356">More...</a><br /></td></tr>
<tr class="separator:a0f875bf4d528885d68581fbd198bf356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310daae8e7f187c090b63aa3514d639c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::vector&lt; std::string &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a310daae8e7f187c090b63aa3514d639c">realization_order</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a310daae8e7f187c090b63aa3514d639c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bunch of functions that call each other, determine an order in which to do the scheduling.  <a href="#a310daae8e7f187c090b63aa3514d639c">More...</a><br /></td></tr>
<tr class="separator:a310daae8e7f187c090b63aa3514d639c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4634146d25cdc2f89c0501ad72ccde"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5a4634146d25cdc2f89c0501ad72ccde">topological_order</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a5a4634146d25cdc2f89c0501ad72ccde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bunch of functions that call each other, determine a topological order which stays constant regardless of the schedule.  <a href="#a5a4634146d25cdc2f89c0501ad72ccde">More...</a><br /></td></tr>
<tr class="separator:a5a4634146d25cdc2f89c0501ad72ccde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcc74570e61290111488ef861e03d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aedcc74570e61290111488ef861e03d0f">split_predicate_test</a> ()</td></tr>
<tr class="separator:aedcc74570e61290111488ef861e03d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8bfb7d84886e922f43c911740f2b1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6b8bfb7d84886e922f43c911740f2b1e">is_func_trivial_to_inline</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;func)</td></tr>
<tr class="memdesc:a6b8bfb7d84886e922f43c911740f2b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the cost of inlining a function is equivalent to the cost of calling the function directly.  <a href="#a6b8bfb7d84886e922f43c911740f2b1e">More...</a><br /></td></tr>
<tr class="separator:a6b8bfb7d84886e922f43c911740f2b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8459c153113e252e4cf11fd16326b065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8459c153113e252e4cf11fd16326b065">remove_dead_allocations</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a8459c153113e252e4cf11fd16326b065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Allocate/Free pairs that are never loaded from or stored to, and remove them from the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>.  <a href="#a8459c153113e252e4cf11fd16326b065">More...</a><br /></td></tr>
<tr class="separator:a8459c153113e252e4cf11fd16326b065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445fa778b28abf135eb1b1d0c8389efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a445fa778b28abf135eb1b1d0c8389efc">remove_trivial_for_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a445fa778b28abf135eb1b1d0c8389efc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> for loops of size 1 into <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a> nodes, which allows for further simplification.  <a href="#a445fa778b28abf135eb1b1d0c8389efc">More...</a><br /></td></tr>
<tr class="separator:a445fa778b28abf135eb1b1d0c8389efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078fe646230de310959c4506c76de02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a078fe646230de310959c4506c76de02e">remove_undef</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a078fe646230de310959c4506c76de02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes stores that depend on undef values, and statements that only contain such stores.  <a href="#a078fe646230de310959c4506c76de02e">More...</a><br /></td></tr>
<tr class="separator:a078fe646230de310959c4506c76de02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9893105833167095e00bf8802a1294f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9893105833167095e00bf8802a1294f1">schedule_functions</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;fused_groups, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, bool &amp;any_memoized)</td></tr>
<tr class="memdesc:a9893105833167095e00bf8802a1294f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build loop nests and inject <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> realizations at the appropriate places using the schedule.  <a href="#a9893105833167095e00bf8802a1294f1">More...</a><br /></td></tr>
<tr class="separator:a9893105833167095e00bf8802a1294f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4242a0b28a7409d2a2489a74795914ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4242a0b28a7409d2a2489a74795914ef"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4242a0b28a7409d2a2489a74795914ef">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a4242a0b28a7409d2a2489a74795914ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6961bbda74000b883fc5759884e4a0b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6961bbda74000b883fc5759884e4a0b0">select_gpu_api</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, <a class="el" href="struct_halide_1_1_target.html">Target</a> t)</td></tr>
<tr class="memdesc:a6961bbda74000b883fc5759884e4a0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace for loops with GPU_Default device_api with an actual device API depending on what's enabled in the target.  <a href="#a6961bbda74000b883fc5759884e4a0b0">More...</a><br /></td></tr>
<tr class="separator:a6961bbda74000b883fc5759884e4a0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c523ca09c58b10c6786b259296dba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab4c523ca09c58b10c6786b259296dba0">simple_autoschedule_test</a> ()</td></tr>
<tr class="separator:ab4c523ca09c58b10c6786b259296dba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d69e4eec54945f92a3b5e4fb7e3e69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a00d69e4eec54945f92a3b5e4fb7e3e69">can_prove</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a00d69e4eec54945f92a3b5e4fb7e3e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">A common use of the simplifier is to prove boolean expressions are true at compile time.  <a href="#a00d69e4eec54945f92a3b5e4fb7e3e69">More...</a><br /></td></tr>
<tr class="separator:a00d69e4eec54945f92a3b5e4fb7e3e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faf83270a59e0cf2e3821be2a4666c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0faf83270a59e0cf2e3821be2a4666c2">simplify_exprs</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:a0faf83270a59e0cf2e3821be2a4666c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify expressions found in a statement, but don't simplify across different statements.  <a href="#a0faf83270a59e0cf2e3821be2a4666c2">More...</a><br /></td></tr>
<tr class="separator:a0faf83270a59e0cf2e3821be2a4666c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adff5495089b812474881ee939c4701c4">mod_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:adff5495089b812474881ee939c4701c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9a60708c880da445554b8eeb778c034">mod_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:ac9a60708c880da445554b8eeb778c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa13a82f37fe6336c154122f66d294523">div_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:aa13a82f37fe6336c154122f66d294523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3965c871f086a60fda2cc31e678d050a">div_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:a3965c871f086a60fda2cc31e678d050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4259425c64a0a9b25760e1c38123c13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af4259425c64a0a9b25760e1c38123c13">simplify_specializations</a> (std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:af4259425c64a0a9b25760e1c38123c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify the RHS/LHS of a function's definition based on its specializations.  <a href="#af4259425c64a0a9b25760e1c38123c13">More...</a><br /></td></tr>
<tr class="separator:af4259425c64a0a9b25760e1c38123c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8489422fe4da6e486b5fd7831aab8bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8489422fe4da6e486b5fd7831aab8bfb">skip_stages</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; std::string &gt; &amp;order)</td></tr>
<tr class="memdesc:a8489422fe4da6e486b5fd7831aab8bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used.  <a href="#a8489422fe4da6e486b5fd7831aab8bfb">More...</a><br /></td></tr>
<tr class="separator:a8489422fe4da6e486b5fd7831aab8bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bde9012b280aad21a569ea008ed296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a07bde9012b280aad21a569ea008ed296">sliding_window</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a07bde9012b280aad21a569ea008ed296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sliding window optimizations on a halide statement.  <a href="#a07bde9012b280aad21a569ea008ed296">More...</a><br /></td></tr>
<tr class="separator:a07bde9012b280aad21a569ea008ed296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f45851f86c88f06e8943d7a73fef4d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7f45851f86c88f06e8943d7a73fef4d8">solve_expression</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;variable, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a7f45851f86c88f06e8943d7a73fef4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to collect all instances of a variable in an expression tree and place it as far to the left as possible, and as far up the tree as possible (i.e.  <a href="#a7f45851f86c88f06e8943d7a73fef4d8">More...</a><br /></td></tr>
<tr class="separator:a7f45851f86c88f06e8943d7a73fef4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802d19074b31d2fda334b5a4cb80aef2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a802d19074b31d2fda334b5a4cb80aef2">solve_for_outer_interval</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c, const std::string &amp;variable)</td></tr>
<tr class="memdesc:a802d19074b31d2fda334b5a4cb80aef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest interval such that the condition is either true or false inside of it, but definitely false outside of it.  <a href="#a802d19074b31d2fda334b5a4cb80aef2">More...</a><br /></td></tr>
<tr class="separator:a802d19074b31d2fda334b5a4cb80aef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1304566ace35a6571c30fb6e1e37d031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1304566ace35a6571c30fb6e1e37d031">solve_for_inner_interval</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c, const std::string &amp;variable)</td></tr>
<tr class="memdesc:a1304566ace35a6571c30fb6e1e37d031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the largest interval such that the condition is definitely true inside of it, and might be true or false outside of it.  <a href="#a1304566ace35a6571c30fb6e1e37d031">More...</a><br /></td></tr>
<tr class="separator:a1304566ace35a6571c30fb6e1e37d031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed16d941f9de01188d0d4cc265d4c6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abed16d941f9de01188d0d4cc265d4c6b">and_condition_over_domain</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;varying)</td></tr>
<tr class="memdesc:abed16d941f9de01188d0d4cc265d4c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a conditional that includes variables that vary over some domain, and convert it to a more conservative (less frequently true) condition that doesn't depend on those variables.  <a href="#abed16d941f9de01188d0d4cc265d4c6b">More...</a><br /></td></tr>
<tr class="separator:abed16d941f9de01188d0d4cc265d4c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1e287e68d69ec35fd8a1e62d1c30ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6e1e287e68d69ec35fd8a1e62d1c30ed">solve_test</a> ()</td></tr>
<tr class="separator:a6e1e287e68d69ec35fd8a1e62d1c30ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be8910393f0a765042cca2d9aa035ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3be8910393f0a765042cca2d9aa035ad">split_tuples</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a3be8910393f0a765042cca2d9aa035ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite all tuple-valued Realizations, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location. ">Provide</a> nodes, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a> nodes into several scalar-valued ones, so that later lowering passes only need to think about scalar-valued productions.  <a href="#a3be8910393f0a765042cca2d9aa035ad">More...</a><br /></td></tr>
<tr class="separator:a3be8910393f0a765042cca2d9aa035ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce34a586ac31d591af744c10b3e5ead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abce34a586ac31d591af744c10b3e5ead">print_to_html</a> (std::string filename, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:abce34a586ac31d591af744c10b3e5ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump an HTML-formatted print of a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> to filename.  <a href="#abce34a586ac31d591af744c10b3e5ead">More...</a><br /></td></tr>
<tr class="separator:abce34a586ac31d591af744c10b3e5ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dce696b85774255e849b8e13737595"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac8dce696b85774255e849b8e13737595">print_to_html</a> (std::string filename, const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;m)</td></tr>
<tr class="memdesc:ac8dce696b85774255e849b8e13737595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump an HTML-formatted print of a <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to filename.  <a href="#ac8dce696b85774255e849b8e13737595">More...</a><br /></td></tr>
<tr class="separator:ac8dce696b85774255e849b8e13737595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac8cb6fe2cb6171bf79124c2c1b1e867f">storage_flattening</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location. ">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true. ">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named symbol if predicate is true. ">Load</a> nodes respectively.  <a href="#ac8cb6fe2cb6171bf79124c2c1b1e867f">More...</a><br /></td></tr>
<tr class="separator:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003d25ab32344023873b630df8fc5719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a003d25ab32344023873b630df8fc5719">storage_folding</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a003d25ab32344023873b630df8fc5719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold storage of functions if possible.  <a href="#a003d25ab32344023873b630df8fc5719">More...</a><br /></td></tr>
<tr class="separator:a003d25ab32344023873b630df8fc5719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a5dab8c12346254d9348060878045c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad8a5dab8c12346254d9348060878045c">strictify_float</a> (std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:ad8a5dab8c12346254d9348060878045c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate strict_float intrinisics such that they immediately wrap all floating-point expressions.  <a href="#ad8a5dab8c12346254d9348060878045c">More...</a><br /></td></tr>
<tr class="separator:ad8a5dab8c12346254d9348060878045c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77fafc3670bd07362c388820dd10c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab77fafc3670bd07362c388820dd10c11">substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab77fafc3670bd07362c388820dd10c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within expr.  <a href="#ab77fafc3670bd07362c388820dd10c11">More...</a><br /></td></tr>
<tr class="separator:ab77fafc3670bd07362c388820dd10c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953484f8812539e108a6c4e137ebfc62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a953484f8812539e108a6c4e137ebfc62">substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a953484f8812539e108a6c4e137ebfc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within stmt.  <a href="#a953484f8812539e108a6c4e137ebfc62">More...</a><br /></td></tr>
<tr class="separator:a953484f8812539e108a6c4e137ebfc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ca85eaf8baf3957bda33b83b20c694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae0ca85eaf8baf3957bda33b83b20c694">target_test</a> ()</td></tr>
<tr class="separator:ae0ca85eaf8baf3957bda33b83b20c694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4e76111f95056b99d8f1fdf108285e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ada4e76111f95056b99d8f1fdf108285e">inject_tracing</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::string &amp;pipeline_name, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;<a class="el" href="struct_halide_1_1_target.html">Target</a>)</td></tr>
<tr class="memdesc:ada4e76111f95056b99d8f1fdf108285e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations.  <a href="#ada4e76111f95056b99d8f1fdf108285e">More...</a><br /></td></tr>
<tr class="separator:ada4e76111f95056b99d8f1fdf108285e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7fd6fdb5eb7b96d5dcf4a9d52985f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aae7fd6fdb5eb7b96d5dcf4a9d52985f7">trim_no_ops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:aae7fd6fdb5eb7b96d5dcf4a9d52985f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate loop bounds to the region over which they actually do something.  <a href="#aae7fd6fdb5eb7b96d5dcf4a9d52985f7">More...</a><br /></td></tr>
<tr class="separator:aae7fd6fdb5eb7b96d5dcf4a9d52985f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6c445013b15af0a32bd54f5bb6bdc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b6c445013b15af0a32bd54f5bb6bdc3">unify_duplicate_lets</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a0b6c445013b15af0a32bd54f5bb6bdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones.  <a href="#a0b6c445013b15af0a32bd54f5bb6bdc3">More...</a><br /></td></tr>
<tr class="separator:a0b6c445013b15af0a32bd54f5bb6bdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf197e316b7d0a6adb96c25976612c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abf197e316b7d0a6adb96c25976612c1b">uniquify_variable_names</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:abf197e316b7d0a6adb96c25976612c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a statement so that every internally-defined variable name is unique.  <a href="#abf197e316b7d0a6adb96c25976612c1b">More...</a><br /></td></tr>
<tr class="separator:abf197e316b7d0a6adb96c25976612c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ffc3710f4a568f3e626e253bc758c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a49ffc3710f4a568f3e626e253bc758c2">unpack_buffers</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a49ffc3710f4a568f3e626e253bc758c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates let stmts for the various buffer components (e.g.  <a href="#a49ffc3710f4a568f3e626e253bc758c2">More...</a><br /></td></tr>
<tr class="separator:a49ffc3710f4a568f3e626e253bc758c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1c49e552297672b3751ac988bf70c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc1c49e552297672b3751ac988bf70c3">unroll_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:adc1c49e552297672b3751ac988bf70c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement.  <a href="#adc1c49e552297672b3751ac988bf70c3">More...</a><br /></td></tr>
<tr class="separator:adc1c49e552297672b3751ac988bf70c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a562085de28dc619511f71c4403fe38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7a562085de28dc619511f71c4403fe38">lower_unsafe_promises</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a7a562085de28dc619511f71c4403fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower all unsafe promises into either assertions or unchecked code, depending on the target.  <a href="#a7a562085de28dc619511f71c4403fe38">More...</a><br /></td></tr>
<tr class="separator:a7a562085de28dc619511f71c4403fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7501900efa7660edf445ed1b14c020c"><td class="memTemplParams" colspan="2">template&lt;typename DST , typename SRC , typename std::enable_if&lt; std::is_floating_point&lt; SRC &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7501900efa7660edf445ed1b14c020c"><td class="memTemplItemLeft" align="right" valign="top">DST&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c">safe_numeric_cast</a> (SRC s)</td></tr>
<tr class="memdesc:ab7501900efa7660edf445ed1b14c020c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some numeric conversions are UB if the value won't fit in the result; <a class="el" href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c" title="Some numeric conversions are UB if the value won&#39;t fit in the result; safe_numeric_cast&lt;&gt;() is meant ...">safe_numeric_cast&lt;&gt;()</a> is meant as a drop-in replacement for a C/C++ cast that adds well-defined behavior for the UB cases, attempting to mimic common implementation behavior as much as possible.  <a href="#ab7501900efa7660edf445ed1b14c020c">More...</a><br /></td></tr>
<tr class="separator:ab7501900efa7660edf445ed1b14c020c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplParams" colspan="2">template&lt;typename DstType , typename SrcType &gt; </td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplItemLeft" align="right" valign="top">DstType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">reinterpret_bits</a> (const SrcType &amp;src)</td></tr>
<tr class="memdesc:a94816d6979fdadb6e206a5d0a668e008"><td class="mdescLeft">&#160;</td><td class="mdescRight">An aggressive form of reinterpret cast used for correct type-punning.  <a href="#a94816d6979fdadb6e206a5d0a668e008">More...</a><br /></td></tr>
<tr class="separator:a94816d6979fdadb6e206a5d0a668e008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d7dfc983d7a320ea1510c24bc55625"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a18d7dfc983d7a320ea1510c24bc55625">make_entity_name</a> (void *stack_ptr, const std::string &amp;type, char prefix)</td></tr>
<tr class="memdesc:a18d7dfc983d7a320ea1510c24bc55625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a unique name for an object based on the name of the stack variable passed in.  <a href="#a18d7dfc983d7a320ea1510c24bc55625">More...</a><br /></td></tr>
<tr class="separator:a18d7dfc983d7a320ea1510c24bc55625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8c7c63ee87658cd904e2f4a0ba78b78b">get_env_variable</a> (char const *env_var_name)</td></tr>
<tr class="memdesc:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of an environment variable.  <a href="#a8c7c63ee87658cd904e2f4a0ba78b78b">More...</a><br /></td></tr>
<tr class="separator:a8c7c63ee87658cd904e2f4a0ba78b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b793745b048fa1fd344907ec4ec9aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab4b793745b048fa1fd344907ec4ec9aa">running_program_name</a> ()</td></tr>
<tr class="memdesc:ab4b793745b048fa1fd344907ec4ec9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the currently running executable.  <a href="#ab4b793745b048fa1fd344907ec4ec9aa">More...</a><br /></td></tr>
<tr class="separator:ab4b793745b048fa1fd344907ec4ec9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26ca52c958b993ebd766f4b83de2cf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af26ca52c958b993ebd766f4b83de2cf9">starts_with</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:af26ca52c958b993ebd766f4b83de2cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the first string starts with the second string.  <a href="#af26ca52c958b993ebd766f4b83de2cf9">More...</a><br /></td></tr>
<tr class="separator:af26ca52c958b993ebd766f4b83de2cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290fb244405de2c014ebdc3cd1fc8f08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a290fb244405de2c014ebdc3cd1fc8f08">ends_with</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a290fb244405de2c014ebdc3cd1fc8f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the first string ends with the second string.  <a href="#a290fb244405de2c014ebdc3cd1fc8f08">More...</a><br /></td></tr>
<tr class="separator:a290fb244405de2c014ebdc3cd1fc8f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c06bf852ad18eb3e9014495f5816c1f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9c06bf852ad18eb3e9014495f5816c1f">replace_all</a> (const std::string &amp;str, const std::string &amp;find, const std::string &amp;replace)</td></tr>
<tr class="memdesc:a9c06bf852ad18eb3e9014495f5816c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches of the second string in the first string with the last string.  <a href="#a9c06bf852ad18eb3e9014495f5816c1f">More...</a><br /></td></tr>
<tr class="separator:a9c06bf852ad18eb3e9014495f5816c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403191721c99e2a88864db3bafbf7b0e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a403191721c99e2a88864db3bafbf7b0e">split_string</a> (const std::string &amp;source, const std::string &amp;delim)</td></tr>
<tr class="memdesc:a403191721c99e2a88864db3bafbf7b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider.  <a href="#a403191721c99e2a88864db3bafbf7b0e">More...</a><br /></td></tr>
<tr class="separator:a403191721c99e2a88864db3bafbf7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaaee1bb2b0dc659851899df7c12437ba">fold_left</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:aaaee1bb2b0dc659851899df7c12437ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a left fold of a vector.  <a href="#aaaee1bb2b0dc659851899df7c12437ba">More...</a><br /></td></tr>
<tr class="separator:aaaee1bb2b0dc659851899df7c12437ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afedfcf82469516f0f05eb5a4699f480a">fold_right</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:afedfcf82469516f0f05eb5a4699f480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a right fold of a vector.  <a href="#afedfcf82469516f0f05eb5a4699f480a">More...</a><br /></td></tr>
<tr class="separator:afedfcf82469516f0f05eb5a4699f480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada89faf6db79c27c47db4f29e18dea92"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </td></tr>
<tr class="memitem:ada89faf6db79c27c47db4f29e18dea92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ada89faf6db79c27c47db4f29e18dea92">collect_paired_args</a> (std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;collected_args, const T3 &amp;a1, const T4 &amp;a2)</td></tr>
<tr class="separator:ada89faf6db79c27c47db4f29e18dea92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de410db20153cd4fa493607e75c962b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename... Args&gt; </td></tr>
<tr class="memitem:a8de410db20153cd4fa493607e75c962b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8de410db20153cd4fa493607e75c962b">collect_paired_args</a> (std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;collected_args, const T3 &amp;a1, const T4 &amp;a2, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a8de410db20153cd4fa493607e75c962b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93192a2ea0afe58664e69232595ae08e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a93192a2ea0afe58664e69232595ae08e">extract_namespaces</a> (const std::string &amp;name, std::vector&lt; std::string &gt; &amp;namespaces)</td></tr>
<tr class="memdesc:a93192a2ea0afe58664e69232595ae08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns base name and fills in namespaces, outermost one first in vector.  <a href="#a93192a2ea0afe58664e69232595ae08e">More...</a><br /></td></tr>
<tr class="separator:a93192a2ea0afe58664e69232595ae08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8aad349dd3bfc69483b792fcab0f96"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4f8aad349dd3bfc69483b792fcab0f96">file_make_temp</a> (const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a4f8aad349dd3bfc69483b792fcab0f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically /tmp, but the specific location is not guaranteed.  <a href="#a4f8aad349dd3bfc69483b792fcab0f96">More...</a><br /></td></tr>
<tr class="separator:a4f8aad349dd3bfc69483b792fcab0f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abaf8a5ee39d2b222d8a0be57894a2f75">dir_make_temp</a> ()</td></tr>
<tr class="memdesc:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique directory in an arbitrary (but writable) directory; this is typically somewhere inside /tmp, but the specific location is not guaranteed.  <a href="#abaf8a5ee39d2b222d8a0be57894a2f75">More...</a><br /></td></tr>
<tr class="separator:abaf8a5ee39d2b222d8a0be57894a2f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2a323363444e3d16237848f6f8715b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff2a323363444e3d16237848f6f8715b">file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aff2a323363444e3d16237848f6f8715b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for access().  <a href="#aff2a323363444e3d16237848f6f8715b">More...</a><br /></td></tr>
<tr class="separator:aff2a323363444e3d16237848f6f8715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034796c3683c3301a09c0102c6adb8b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a034796c3683c3301a09c0102c6adb8b0">assert_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a034796c3683c3301a09c0102c6adb8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">assert-fail if the file doesn't exist.  <a href="#a034796c3683c3301a09c0102c6adb8b0">More...</a><br /></td></tr>
<tr class="separator:a034796c3683c3301a09c0102c6adb8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab8356033bf440e2f990bdc9f27cdcdcf">assert_no_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">assert-fail if the file DOES exist.  <a href="#ab8356033bf440e2f990bdc9f27cdcdcf">More...</a><br /></td></tr>
<tr class="separator:ab8356033bf440e2f990bdc9f27cdcdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a05dd8ec86534a0e22d1ab4f2037bc562">file_unlink</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for unlink().  <a href="#a05dd8ec86534a0e22d1ab4f2037bc562">More...</a><br /></td></tr>
<tr class="separator:a05dd8ec86534a0e22d1ab4f2037bc562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c611b7403f5613f08fb701ea6eed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a947c611b7403f5613f08fb701ea6eed6">ensure_no_file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a947c611b7403f5613f08fb701ea6eed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that no file with this path exists.  <a href="#a947c611b7403f5613f08fb701ea6eed6">More...</a><br /></td></tr>
<tr class="separator:a947c611b7403f5613f08fb701ea6eed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710588d377ce398aa366fc00f6d436aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a710588d377ce398aa366fc00f6d436aa">dir_rmdir</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a710588d377ce398aa366fc00f6d436aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rmdir().  <a href="#a710588d377ce398aa366fc00f6d436aa">More...</a><br /></td></tr>
<tr class="separator:a710588d377ce398aa366fc00f6d436aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f41b4199ab2236fb4056661f20cc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa0f41b4199ab2236fb4056661f20cc11">file_stat</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa0f41b4199ab2236fb4056661f20cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for stat().  <a href="#aa0f41b4199ab2236fb4056661f20cc11">More...</a><br /></td></tr>
<tr class="separator:aa0f41b4199ab2236fb4056661f20cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342a753f8441a0b29418b0d22cbda86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae342a753f8441a0b29418b0d22cbda86">halide_tic_impl</a> (const char *file, int line)</td></tr>
<tr class="separator:ae342a753f8441a0b29418b0d22cbda86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23694d45bd4c42ec1dc97a17bb78f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7c23694d45bd4c42ec1dc97a17bb78f6">halide_toc_impl</a> (const char *file, int line)</td></tr>
<tr class="separator:a7c23694d45bd4c42ec1dc97a17bb78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7006f0b4b15257feedd9e57d1288dc97"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7006f0b4b15257feedd9e57d1288dc97">make_argument_list</a> (int dimensionality)</td></tr>
<tr class="memdesc:a7006f0b4b15257feedd9e57d1288dc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a list of unique arguments for definitions with unnamed arguments.  <a href="#a7006f0b4b15257feedd9e57d1288dc97">More...</a><br /></td></tr>
<tr class="separator:a7006f0b4b15257feedd9e57d1288dc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfef059a37f995f9434f836bdbc1edd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adcfef059a37f995f9434f836bdbc1edd">find_linear_expressions</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:adcfef059a37f995f9434f836bdbc1edd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal.html#adcfef059a37f995f9434f836bdbc1edd" title="find_linear_expressions(Stmt s) identifies expressions that may be moved out of the generated fragmen...">find_linear_expressions(Stmt s)</a> identifies expressions that may be moved out of the generated fragment shader into a varying attribute.  <a href="#adcfef059a37f995f9434f836bdbc1edd">More...</a><br /></td></tr>
<tr class="separator:adcfef059a37f995f9434f836bdbc1edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523c0d5dea7bfbd664e8506ebb7016de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a523c0d5dea7bfbd664e8506ebb7016de">setup_gpu_vertex_buffer</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a523c0d5dea7bfbd664e8506ebb7016de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a set of 2D mesh coordinates based on the behavior of varying attribute expressions contained within a GLSL scheduled for loop.  <a href="#a523c0d5dea7bfbd664e8506ebb7016de">More...</a><br /></td></tr>
<tr class="separator:a523c0d5dea7bfbd664e8506ebb7016de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d8d64a1298f1e0abd71fd0eeada10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae1d8d64a1298f1e0abd71fd0eeada10b">vectorize_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:ae1d8d64a1298f1e0abd71fd0eeada10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors.  <a href="#ae1d8d64a1298f1e0abd71fd0eeada10b">More...</a><br /></td></tr>
<tr class="separator:ae1d8d64a1298f1e0abd71fd0eeada10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ba0a978ebdc5f1866290752bd76e6d"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a47ba0a978ebdc5f1866290752bd76e6d">wrap_func_calls</a> (const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a47ba0a978ebdc5f1866290752bd76e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace every call to wrapped Functions in the Functions' definitions with call to their wrapper functions.  <a href="#a47ba0a978ebdc5f1866290752bd76e6d">More...</a><br /></td></tr>
<tr class="separator:a47ba0a978ebdc5f1866290752bd76e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af194834e3759a2a96d3929d8c9938395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af194834e3759a2a96d3929d8c9938395">wrap_legacy_extern_stages</a> (<a class="el" href="class_halide_1_1_module.html">Module</a> m)</td></tr>
<tr class="memdesc:af194834e3759a2a96d3929d8c9938395"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> wrappers for any LoweredFuncs that need them to support backwards compatibility.  <a href="#af194834e3759a2a96d3929d8c9938395">More...</a><br /></td></tr>
<tr class="separator:af194834e3759a2a96d3929d8c9938395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6fd6e0ae9234b9b435b13f432ae199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afe6fd6e0ae9234b9b435b13f432ae199">add_legacy_wrapper</a> (<a class="el" href="class_halide_1_1_module.html">Module</a> m, const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;fn)</td></tr>
<tr class="memdesc:afe6fd6e0ae9234b9b435b13f432ae199"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> a wrapper for a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function. ">LoweredFunc</a> that accepts old buffers and upgrades them.  <a href="#afe6fd6e0ae9234b9b435b13f432ae199">More...</a><br /></td></tr>
<tr class="separator:afe6fd6e0ae9234b9b435b13f432ae199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a10382115757a18cd8ab8d674079ff4d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a10382115757a18cd8ab8d674079ff4d7">subsitute_var_estimates</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a10382115757a18cd8ab8d674079ff4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute every variable in an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> with its estimate if specified.  <a href="#a10382115757a18cd8ab8d674079ff4d7">More...</a><br /></td></tr>
<tr class="separator:a10382115757a18cd8ab8d674079ff4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fedcbbefe49e3df748c309938cf7f66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6fedcbbefe49e3df748c309938cf7f66">subsitute_var_estimates</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a6fedcbbefe49e3df748c309938cf7f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute every variable in an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> with its estimate if specified.  <a href="#a6fedcbbefe49e3df748c309938cf7f66">More...</a><br /></td></tr>
<tr class="separator:a6fedcbbefe49e3df748c309938cf7f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a765c203107b702636e6f2cf5ba896f95"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a765c203107b702636e6f2cf5ba896f95"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a765c203107b702636e6f2cf5ba896f95">get_element</a> (const std::map&lt; K, V &gt; &amp;m, const K &amp;key)</td></tr>
<tr class="memdesc:a765c203107b702636e6f2cf5ba896f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value of element within a map.  <a href="#a765c203107b702636e6f2cf5ba896f95">More...</a><br /></td></tr>
<tr class="separator:a765c203107b702636e6f2cf5ba896f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525a46ec18d54c5534ccccc9e21ac262"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a525a46ec18d54c5534ccccc9e21ac262"><td class="memTemplItemLeft" align="right" valign="top">V &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a525a46ec18d54c5534ccccc9e21ac262">get_element</a> (std::map&lt; K, V &gt; &amp;m, const K &amp;key)</td></tr>
<tr class="memdesc:a525a46ec18d54c5534ccccc9e21ac262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value of element within a map.  <a href="#a525a46ec18d54c5534ccccc9e21ac262">More...</a><br /></td></tr>
<tr class="separator:a525a46ec18d54c5534ccccc9e21ac262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab68083f9769cbbf033176ba50f3709c9"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab68083f9769cbbf033176ba50f3709c9">boxes_required</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ab68083f9769cbbf033176ba50f3709c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression.  <a href="#ab68083f9769cbbf033176ba50f3709c9">More...</a><br /></td></tr>
<tr class="separator:ab68083f9769cbbf033176ba50f3709c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f12c0072dbbf9639829af1aedda4ea"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af1f12c0072dbbf9639829af1aedda4ea">boxes_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:af1f12c0072dbbf9639829af1aedda4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression.  <a href="#af1f12c0072dbbf9639829af1aedda4ea">More...</a><br /></td></tr>
<tr class="separator:af1f12c0072dbbf9639829af1aedda4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aeaf945673dc90b8bdd2e79900b147954"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aeaf945673dc90b8bdd2e79900b147954">boxes_provided</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:aeaf945673dc90b8bdd2e79900b147954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression.  <a href="#aeaf945673dc90b8bdd2e79900b147954">More...</a><br /></td></tr>
<tr class="separator:aeaf945673dc90b8bdd2e79900b147954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c4633706bdb6855b69fb9146ee65ff"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae6c4633706bdb6855b69fb9146ee65ff">boxes_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ae6c4633706bdb6855b69fb9146ee65ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression.  <a href="#ae6c4633706bdb6855b69fb9146ee65ff">More...</a><br /></td></tr>
<tr class="separator:ae6c4633706bdb6855b69fb9146ee65ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae5c5855f4212c1cb3880a8534b6f41b6"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae5c5855f4212c1cb3880a8534b6f41b6">boxes_touched</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ae5c5855f4212c1cb3880a8534b6f41b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression.  <a href="#ae5c5855f4212c1cb3880a8534b6f41b6">More...</a><br /></td></tr>
<tr class="separator:ae5c5855f4212c1cb3880a8534b6f41b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbd14233932a8f658ac66d45e00d7fb"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0fbd14233932a8f658ac66d45e00d7fb">boxes_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a0fbd14233932a8f658ac66d45e00d7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression.  <a href="#a0fbd14233932a8f658ac66d45e00d7fb">More...</a><br /></td></tr>
<tr class="separator:a0fbd14233932a8f658ac66d45e00d7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a69980b5d1669ec54e78b7d393d8a7201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a69980b5d1669ec54e78b7d393d8a7201">box_required</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a69980b5d1669ec54e78b7d393d8a7201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a69980b5d1669ec54e78b7d393d8a7201">More...</a><br /></td></tr>
<tr class="separator:a69980b5d1669ec54e78b7d393d8a7201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6ad02cea8b0bacbb0b3c1f644af501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aea6ad02cea8b0bacbb0b3c1f644af501">box_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:aea6ad02cea8b0bacbb0b3c1f644af501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#aea6ad02cea8b0bacbb0b3c1f644af501">More...</a><br /></td></tr>
<tr class="separator:aea6ad02cea8b0bacbb0b3c1f644af501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0586fc0706c9a4d39f0ae5f9c7073c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0586fc0706c9a4d39f0ae5f9c7073c86">box_provided</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a0586fc0706c9a4d39f0ae5f9c7073c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a0586fc0706c9a4d39f0ae5f9c7073c86">More...</a><br /></td></tr>
<tr class="separator:a0586fc0706c9a4d39f0ae5f9c7073c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4d7463fc7d96132bbe01768f967dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9d4d7463fc7d96132bbe01768f967dd6">box_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a9d4d7463fc7d96132bbe01768f967dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a9d4d7463fc7d96132bbe01768f967dd6">More...</a><br /></td></tr>
<tr class="separator:a9d4d7463fc7d96132bbe01768f967dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa211ee508998ef25191d04fa45eb16c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa211ee508998ef25191d04fa45eb16c7">box_touched</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:aa211ee508998ef25191d04fa45eb16c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#aa211ee508998ef25191d04fa45eb16c7">More...</a><br /></td></tr>
<tr class="separator:aa211ee508998ef25191d04fa45eb16c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a819815a3d7f37a441a22c06689689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a35a819815a3d7f37a441a22c06689689">box_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a35a819815a3d7f37a441a22c06689689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a35a819815a3d7f37a441a22c06689689">More...</a><br /></td></tr>
<tr class="separator:a35a819815a3d7f37a441a22c06689689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7a4f18b650b23e1e6ed980d1feebcf5">lower_euclidean_div</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero.  <a href="#ab7a4f18b650b23e1e6ed980d1feebcf5">More...</a><br /></td></tr>
<tr class="separator:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d78fd7f3115750e17167ebf0fe920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae81d78fd7f3115750e17167ebf0fe920">lower_euclidean_mod</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ae81d78fd7f3115750e17167ebf0fe920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero.  <a href="#ae81d78fd7f3115750e17167ebf0fe920">More...</a><br /></td></tr>
<tr class="separator:ae81d78fd7f3115750e17167ebf0fe920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a13202cdbaa52c465421a8bcfda356d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a13202cdbaa52c465421a8bcfda356d9d">eliminate_bool_vectors</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a13202cdbaa52c465421a8bcfda356d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on.  <a href="#a13202cdbaa52c465421a8bcfda356d9d">More...</a><br /></td></tr>
<tr class="separator:a13202cdbaa52c465421a8bcfda356d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb97941d92283c2daa7075a5db09bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1bb97941d92283c2daa7075a5db09bfd">eliminate_bool_vectors</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> s)</td></tr>
<tr class="memdesc:a1bb97941d92283c2daa7075a5db09bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on.  <a href="#a1bb97941d92283c2daa7075a5db09bfd">More...</a><br /></td></tr>
<tr class="separator:a1bb97941d92283c2daa7075a5db09bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b45ec55494eb56aa834b6df8ab6f095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6b45ec55494eb56aa834b6df8ab6f095">native_deinterleave</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a6b45ec55494eb56aa834b6df8ab6f095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate deinterleave or interleave operations, operating on groups of vectors at a time.  <a href="#a6b45ec55494eb56aa834b6df8ab6f095">More...</a><br /></td></tr>
<tr class="separator:a6b45ec55494eb56aa834b6df8ab6f095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f57cdbcddfbe9985a1d491c5f2de087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8f57cdbcddfbe9985a1d491c5f2de087">native_interleave</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a8f57cdbcddfbe9985a1d491c5f2de087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate deinterleave or interleave operations, operating on groups of vectors at a time.  <a href="#a8f57cdbcddfbe9985a1d491c5f2de087">More...</a><br /></td></tr>
<tr class="separator:a8f57cdbcddfbe9985a1d491c5f2de087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c6471944a1cc0064f3c6aed326a3d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a90c6471944a1cc0064f3c6aed326a3d2">is_native_deinterleave</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a90c6471944a1cc0064f3c6aed326a3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate deinterleave or interleave operations, operating on groups of vectors at a time.  <a href="#a90c6471944a1cc0064f3c6aed326a3d2">More...</a><br /></td></tr>
<tr class="separator:a90c6471944a1cc0064f3c6aed326a3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dfa8a0a83f7b7e41c320186093847c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af6dfa8a0a83f7b7e41c320186093847c">is_native_interleave</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:af6dfa8a0a83f7b7e41c320186093847c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate deinterleave or interleave operations, operating on groups of vectors at a time.  <a href="#af6dfa8a0a83f7b7e41c320186093847c">More...</a><br /></td></tr>
<tr class="separator:af6dfa8a0a83f7b7e41c320186093847c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a846846d97dbb9c2db23a476126163645"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a846846d97dbb9c2db23a476126163645">inline_function</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:a846846d97dbb9c2db23a476126163645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <a href="#a846846d97dbb9c2db23a476126163645">More...</a><br /></td></tr>
<tr class="separator:a846846d97dbb9c2db23a476126163645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d4d98216185149bb2d834223dde889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a74d4d98216185149bb2d834223dde889">inline_function</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:a74d4d98216185149bb2d834223dde889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <a href="#a74d4d98216185149bb2d834223dde889">More...</a><br /></td></tr>
<tr class="separator:a74d4d98216185149bb2d834223dde889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1534ff08ab7d94326aac9f617591156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab1534ff08ab7d94326aac9f617591156">inline_function</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> caller, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:ab1534ff08ab7d94326aac9f617591156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <a href="#ab1534ff08ab7d94326aac9f617591156">More...</a><br /></td></tr>
<tr class="separator:ab1534ff08ab7d94326aac9f617591156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a591b432e75725e61702af6b05d7c9d76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a591b432e75725e61702af6b05d7c9d76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a591b432e75725e61702af6b05d7c9d76">ref_count</a> (const T *t)</td></tr>
<tr class="memdesc:a591b432e75725e61702af6b05d7c9d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="#a591b432e75725e61702af6b05d7c9d76">More...</a><br /></td></tr>
<tr class="separator:a591b432e75725e61702af6b05d7c9d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca920b642ef490aeac2b4e864d6254"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11ca920b642ef490aeac2b4e864d6254"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a11ca920b642ef490aeac2b4e864d6254">destroy</a> (const T *t)</td></tr>
<tr class="memdesc:a11ca920b642ef490aeac2b4e864d6254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="#a11ca920b642ef490aeac2b4e864d6254">More...</a><br /></td></tr>
<tr class="separator:a11ca920b642ef490aeac2b4e864d6254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1074fbd76b40a9cc210fbd22fdcda914"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1074fbd76b40a9cc210fbd22fdcda914">equal</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a1074fbd76b40a9cc210fbd22fdcda914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a1074fbd76b40a9cc210fbd22fdcda914">More...</a><br /></td></tr>
<tr class="separator:a1074fbd76b40a9cc210fbd22fdcda914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705ef4763a82b7907112099a01604d0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a705ef4763a82b7907112099a01604d0d">equal</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;b)</td></tr>
<tr class="memdesc:a705ef4763a82b7907112099a01604d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a705ef4763a82b7907112099a01604d0d">More...</a><br /></td></tr>
<tr class="separator:a705ef4763a82b7907112099a01604d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fad2884f65d9bbb20c6cdcc65e08d47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3fad2884f65d9bbb20c6cdcc65e08d47">graph_equal</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a3fad2884f65d9bbb20c6cdcc65e08d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a3fad2884f65d9bbb20c6cdcc65e08d47">More...</a><br /></td></tr>
<tr class="separator:a3fad2884f65d9bbb20c6cdcc65e08d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b5e9d7137c035d913570030d474bac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a31b5e9d7137c035d913570030d474bac">graph_equal</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;b)</td></tr>
<tr class="memdesc:a31b5e9d7137c035d913570030d474bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a31b5e9d7137c035d913570030d474bac">More...</a><br /></td></tr>
<tr class="separator:a31b5e9d7137c035d913570030d474bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5a057ef6ceb8462dbca18eb9020bc297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a5a057ef6ceb8462dbca18eb9020bc297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a5a057ef6ceb8462dbca18eb9020bc297">More...</a><br /></td></tr>
<tr class="separator:a5a057ef6ceb8462dbca18eb9020bc297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69927d11c0fe7c6cf4092a811f6676d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a69927d11c0fe7c6cf4092a811f6676d7">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val)</td></tr>
<tr class="memdesc:a69927d11c0fe7c6cf4092a811f6676d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a69927d11c0fe7c6cf4092a811f6676d7">More...</a><br /></td></tr>
<tr class="separator:a69927d11c0fe7c6cf4092a811f6676d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a72bc2d5b95e6a43e803a9f7c4acea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad3a72bc2d5b95e6a43e803a9f7c4acea">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, double val)</td></tr>
<tr class="memdesc:ad3a72bc2d5b95e6a43e803a9f7c4acea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#ad3a72bc2d5b95e6a43e803a9f7c4acea">More...</a><br /></td></tr>
<tr class="separator:ad3a72bc2d5b95e6a43e803a9f7c4acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaae8ca905f0ce9cde74cc0897a61c4e7">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> val)</td></tr>
<tr class="memdesc:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#aaae8ca905f0ce9cde74cc0897a61c4e7">More...</a><br /></td></tr>
<tr class="separator:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b64c00a450c92807011cdc02f8b29b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70b64c00a450c92807011cdc02f8b29b">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> val)</td></tr>
<tr class="memdesc:a70b64c00a450c92807011cdc02f8b29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a70b64c00a450c92807011cdc02f8b29b">More...</a><br /></td></tr>
<tr class="separator:a70b64c00a450c92807011cdc02f8b29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df9ef655a78f9fb233fa0322525496c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4df9ef655a78f9fb233fa0322525496c">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a> val)</td></tr>
<tr class="memdesc:a4df9ef655a78f9fb233fa0322525496c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a4df9ef655a78f9fb233fa0322525496c">More...</a><br /></td></tr>
<tr class="separator:a4df9ef655a78f9fb233fa0322525496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af14e2dade91eb04482b4b5ffdfc920dd">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a> val)</td></tr>
<tr class="memdesc:af14e2dade91eb04482b4b5ffdfc920dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#af14e2dade91eb04482b4b5ffdfc920dd">More...</a><br /></td></tr>
<tr class="separator:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5231b80b8e1a7904cdd4fcac7b89a98d">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a> val)</td></tr>
<tr class="memdesc:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a5231b80b8e1a7904cdd4fcac7b89a98d">More...</a><br /></td></tr>
<tr class="separator:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae9a1ece36d20a64a59c92bf7f8c4e9aa">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> val)</td></tr>
<tr class="memdesc:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#ae9a1ece36d20a64a59c92bf7f8c4e9aa">More...</a><br /></td></tr>
<tr class="separator:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#addbd965eccbcfc1f5b80eaa0607f698c">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, bool val)</td></tr>
<tr class="memdesc:addbd965eccbcfc1f5b80eaa0607f698c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#addbd965eccbcfc1f5b80eaa0607f698c">More...</a><br /></td></tr>
<tr class="separator:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90929bcfb18413ffd527152bb8580de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa90929bcfb18413ffd527152bb8580de">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, float val)</td></tr>
<tr class="memdesc:aa90929bcfb18413ffd527152bb8580de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#aa90929bcfb18413ffd527152bb8580de">More...</a><br /></td></tr>
<tr class="separator:aa90929bcfb18413ffd527152bb8580de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592ef00a06a1d8f017b48359099c16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6592ef00a06a1d8f017b48359099c16d">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1float16__t.html">float16_t</a> val)</td></tr>
<tr class="memdesc:a6592ef00a06a1d8f017b48359099c16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a6592ef00a06a1d8f017b48359099c16d">More...</a><br /></td></tr>
<tr class="separator:a6592ef00a06a1d8f017b48359099c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1953dca5a0981d186fc050a1deace06b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1953dca5a0981d186fc050a1deace06b">halide_log</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a1953dca5a0981d186fc050a1deace06b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="#a1953dca5a0981d186fc050a1deace06b">More...</a><br /></td></tr>
<tr class="separator:a1953dca5a0981d186fc050a1deace06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b9fcbf1259db14123bffa40c5bae56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af0b9fcbf1259db14123bffa40c5bae56">halide_exp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:af0b9fcbf1259db14123bffa40c5bae56"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="#af0b9fcbf1259db14123bffa40c5bae56">More...</a><br /></td></tr>
<tr class="separator:af0b9fcbf1259db14123bffa40c5bae56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1307e62672d75c2f542f37430b3239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0c1307e62672d75c2f542f37430b3239">halide_erf</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a0c1307e62672d75c2f542f37430b3239"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="#a0c1307e62672d75c2f542f37430b3239">More...</a><br /></td></tr>
<tr class="separator:a0c1307e62672d75c2f542f37430b3239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af210d0f6ae102d704259f49bb32adc2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af210d0f6ae102d704259f49bb32adc2f">reduce_expr_modulo</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int modulus, int *remainder)</td></tr>
<tr class="memdesc:af210d0f6ae102d704259f49bb32adc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <a href="#af210d0f6ae102d704259f49bb32adc2f">More...</a><br /></td></tr>
<tr class="separator:af210d0f6ae102d704259f49bb32adc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d47052fb0609cee3c7117c4f595e98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af7d47052fb0609cee3c7117c4f595e98">reduce_expr_modulo</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int modulus, int *remainder, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:af7d47052fb0609cee3c7117c4f595e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <a href="#af7d47052fb0609cee3c7117c4f595e98">More...</a><br /></td></tr>
<tr class="separator:af7d47052fb0609cee3c7117c4f595e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a281c43601ef9ba6a584dbfa8ecd39e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a281c43601ef9ba6a584dbfa8ecd39e1a">simplify</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, bool remove_dead_lets=true, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a281c43601ef9ba6a584dbfa8ecd39e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="#a281c43601ef9ba6a584dbfa8ecd39e1a">More...</a><br /></td></tr>
<tr class="separator:a281c43601ef9ba6a584dbfa8ecd39e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6405a74f3c241d60365e510a4e698808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6405a74f3c241d60365e510a4e698808">simplify</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, bool remove_dead_lets=true, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a6405a74f3c241d60365e510a4e698808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="#a6405a74f3c241d60365e510a4e698808">More...</a><br /></td></tr>
<tr class="separator:a6405a74f3c241d60365e510a4e698808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">mod_imp</a> (T a, T b)</td></tr>
<tr class="memdesc:a6cd3908859c82249a2c7f10158883a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>.  <a href="#a6cd3908859c82249a2c7f10158883a97">More...</a><br /></td></tr>
<tr class="separator:a6cd3908859c82249a2c7f10158883a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">div_imp</a> (T a, T b)</td></tr>
<tr class="memdesc:a0442f9a0450f45683938a69ce0273974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>.  <a href="#a0442f9a0450f45683938a69ce0273974">More...</a><br /></td></tr>
<tr class="separator:a0442f9a0450f45683938a69ce0273974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a92d044309ede4782cabce475570934a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a92d044309ede4782cabce475570934a8">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a92d044309ede4782cabce475570934a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="#a92d044309ede4782cabce475570934a8">More...</a><br /></td></tr>
<tr class="separator:a92d044309ede4782cabce475570934a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ebb6536c3233e6466073757f0e59e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a14ebb6536c3233e6466073757f0e59e7">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a14ebb6536c3233e6466073757f0e59e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="#a14ebb6536c3233e6466073757f0e59e7">More...</a><br /></td></tr>
<tr class="separator:a14ebb6536c3233e6466073757f0e59e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a07967ab74e22a0103d6af67ec62cc3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a07967ab74e22a0103d6af67ec62cc3b7">substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a07967ab74e22a0103d6af67ec62cc3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute expressions for other expressions.  <a href="#a07967ab74e22a0103d6af67ec62cc3b7">More...</a><br /></td></tr>
<tr class="separator:a07967ab74e22a0103d6af67ec62cc3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b12ab6ef3f59e897315145d1e996e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae1b12ab6ef3f59e897315145d1e996e2">substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:ae1b12ab6ef3f59e897315145d1e996e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute expressions for other expressions.  <a href="#ae1b12ab6ef3f59e897315145d1e996e2">More...</a><br /></td></tr>
<tr class="separator:ae1b12ab6ef3f59e897315145d1e996e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a457e67268c787fe55a7bc5e3559f43cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a457e67268c787fe55a7bc5e3559f43cc">graph_substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a457e67268c787fe55a7bc5e3559f43cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutions where the IR may be a general graph (and not just a DAG).  <a href="#a457e67268c787fe55a7bc5e3559f43cc">More...</a><br /></td></tr>
<tr class="separator:a457e67268c787fe55a7bc5e3559f43cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95627cc6470e3f8975ab3b1fa2048e3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a95627cc6470e3f8975ab3b1fa2048e3e">graph_substitute</a> (const std::string &amp;name, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a95627cc6470e3f8975ab3b1fa2048e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutions where the IR may be a general graph (and not just a DAG).  <a href="#a95627cc6470e3f8975ab3b1fa2048e3e">More...</a><br /></td></tr>
<tr class="separator:a95627cc6470e3f8975ab3b1fa2048e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8219abd8f63bb237e29a7b878a445836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8219abd8f63bb237e29a7b878a445836">graph_substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a8219abd8f63bb237e29a7b878a445836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutions where the IR may be a general graph (and not just a DAG).  <a href="#a8219abd8f63bb237e29a7b878a445836">More...</a><br /></td></tr>
<tr class="separator:a8219abd8f63bb237e29a7b878a445836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e9db71fa11a9eb45590a8fd5ff774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1d8e9db71fa11a9eb45590a8fd5ff774">graph_substitute</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;find, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;replacement, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a1d8e9db71fa11a9eb45590a8fd5ff774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutions where the IR may be a general graph (and not just a DAG).  <a href="#a1d8e9db71fa11a9eb45590a8fd5ff774">More...</a><br /></td></tr>
<tr class="separator:a1d8e9db71fa11a9eb45590a8fd5ff774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaafce6d574b476cf9c9acd5f622450ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaafce6d574b476cf9c9acd5f622450ab">substitute_in_all_lets</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aaafce6d574b476cf9c9acd5f622450ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute in all let Exprs in a piece of IR.  <a href="#aaafce6d574b476cf9c9acd5f622450ab">More...</a><br /></td></tr>
<tr class="separator:aaafce6d574b476cf9c9acd5f622450ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a57aa0cf600e63ac832ea799f354acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6a57aa0cf600e63ac832ea799f354acc">substitute_in_all_lets</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a6a57aa0cf600e63ac832ea799f354acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute in all let Exprs in a piece of IR.  <a href="#a6a57aa0cf600e63ac832ea799f354acc">More...</a><br /></td></tr>
<tr class="separator:a6a57aa0cf600e63ac832ea799f354acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aabd490221160a7206bb151d6eae65624"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aabd490221160a7206bb151d6eae65624">unique_name</a> (char prefix)</td></tr>
<tr class="memdesc:aabd490221160a7206bb151d6eae65624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given prefix.  <a href="#aabd490221160a7206bb151d6eae65624">More...</a><br /></td></tr>
<tr class="separator:aabd490221160a7206bb151d6eae65624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec0bd73d997ddc50f3523a21448471f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7ec0bd73d997ddc50f3523a21448471f">unique_name</a> (const std::string &amp;prefix)</td></tr>
<tr class="memdesc:a7ec0bd73d997ddc50f3523a21448471f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given prefix.  <a href="#a7ec0bd73d997ddc50f3523a21448471f">More...</a><br /></td></tr>
<tr class="separator:a7ec0bd73d997ddc50f3523a21448471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8cc678d669d07fdd15685b87e3b8b620"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8cc678d669d07fdd15685b87e3b8b620">add_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a8cc678d669d07fdd15685b87e3b8b620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to test if math would overflow for signed integers with the given number of bits.  <a href="#a8cc678d669d07fdd15685b87e3b8b620">More...</a><br /></td></tr>
<tr class="separator:a8cc678d669d07fdd15685b87e3b8b620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a82c64641e261b5596a2ab6d7da7f8ef8">sub_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to test if math would overflow for signed integers with the given number of bits.  <a href="#a82c64641e261b5596a2ab6d7da7f8ef8">More...</a><br /></td></tr>
<tr class="separator:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaa735c9ff93372dce25222fb551b67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9aaa735c9ff93372dce25222fb551b67">mul_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a9aaa735c9ff93372dce25222fb551b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to test if math would overflow for signed integers with the given number of bits.  <a href="#a9aaa735c9ff93372dce25222fb551b67">More...</a><br /></td></tr>
<tr class="separator:a9aaa735c9ff93372dce25222fb551b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac4e8d52841afa71f1f7bac7ce9611159"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac4e8d52841afa71f1f7bac7ce9611159">unknown</a> = std::numeric_limits&lt;<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&gt;::<a class="el" href="namespace_halide.html#ab6f20de22e199a01ee4b40d61011ed69">min</a>()</td></tr>
<tr class="separator:ac4e8d52841afa71f1f7bac7ce9611159"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="abff8dba5612d856cc2acfab99e3cf479"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">Halide::Internal::DimBounds</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00020">20</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaa0611a86047e2c583dd061a620dcc6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;std::string, int&gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">Halide::Internal::FuncValueBounds</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_bounds_8h_source.html#l00016">16</a> of file <a class="el" href="_bounds_8h_source.html">Bounds.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae0c76d77a93240aaabd916abf0b10beb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#ae0c76d77a93240aaabd916abf0b10beb">Halide::Internal::add_const_if_T_is_const</a> = typedef typename std::conditional&lt;std::is_const&lt;T&gt;::value, const T2, T2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00080">80</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9ee415bddc2cb4a392f5411485d740d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#a9ee415bddc2cb4a392f5411485d740d0">Halide::Internal::FuncBounds</a> = typedef std::vector&lt;std::pair&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_derivative_utils_8h_source.html#l00014">14</a> of file <a class="el" href="_derivative_utils_8h_source.html">DerivativeUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4ad95b1366360901b824afd5282754f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#ac4ad95b1366360901b824afd5282754f">Halide::Internal::GeneratorParamImplBase</a> = typedef typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, <a class="el" href="struct_halide_1_1_target.html">Target</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">GeneratorParam_Target</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, <a class="el" href="struct_halide_1_1_machine_params.html">MachineParams</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___machine_params.html">GeneratorParam_MachineParams</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, <a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___loop_level.html">GeneratorParam_LoopLevel</a>&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, <a class="el" href="struct_halide_1_1_type.html">Type</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">GeneratorParam_Type</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;T, bool&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">GeneratorParam_Bool</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_arithmetic&lt;T&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">GeneratorParam_Arithmetic</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_enum&lt;T&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">GeneratorParam_Enum</a>&lt;T&gt;&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l00855">855</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa4f2df17f3c13c09f5cbd2672f2a6902"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#aa4f2df17f3c13c09f5cbd2672f2a6902">Halide::Internal::GeneratorInputImplBase</a> = typedef typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a>&lt;TBase&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___buffer.html">GeneratorInput_Buffer</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;TBase, <a class="el" href="class_halide_1_1_func.html">Func</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___func.html">GeneratorInput_Func</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_arithmetic&lt;TBase&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___arithmetic.html">GeneratorInput_Arithmetic</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_scalar&lt;TBase&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_input___scalar.html">GeneratorInput_Scalar</a>&lt;T&gt;&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l01798">1798</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a65269e471e6b0c035abc3e3be6d3185b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TBase  = typename std::remove_all_extents&lt;T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#a65269e471e6b0c035abc3e3be6d3185b">Halide::Internal::GeneratorOutputImplBase</a> = typedef typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;<a class="el" href="struct_halide_1_1_internal_1_1has__static__halide__type__method.html">has_static_halide_type_method</a>&lt;TBase&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___buffer.html">GeneratorOutput_Buffer</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_same&lt;TBase, <a class="el" href="class_halide_1_1_func.html">Func</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___func.html">GeneratorOutput_Func</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>&lt;std::is_arithmetic&lt;TBase&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_output___arithmetic.html">GeneratorOutput_Arithmetic</a>&lt;T&gt;&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l02295">2295</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a232fef1d5718a2d032a8f82b11ea1633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#a232fef1d5718a2d032a8f82b11ea1633">Halide::Internal::GeneratorFactory</a> = typedef std::function&lt;std::unique_ptr&lt;<a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">GeneratorBase</a>&gt;(const <a class="el" href="class_halide_1_1_generator_context.html">GeneratorContext</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l02609">2609</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9e4e2eb6b31542f36a2c879aa18c48a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#a9e4e2eb6b31542f36a2c879aa18c48a7">Halide::Internal::GeneratorParamsMap</a> = typedef std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_string_or_loop_level.html">StringOrLoopLevel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l02620">2620</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a class="anchor" id="abd1b9521b6f1f513178f281d8f395335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Halide::Internal::Region</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A multi-dimensional box. </p>
<p>The outer product of the elements </p>

<p>Definition at line <a class="el" href="_i_r_8h_source.html#l00397">397</a> of file <a class="el" href="_i_r_8h_source.html">IR.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab837f22cfa4bfe22dba01f4908e839ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* Halide::Internal::halide_task) (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_j_i_t_module_8h_source.html#l00123">123</a> of file <a class="el" href="_j_i_t_module_8h_source.html">JITModule.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7114c2dcec2af79da28735c5b11c0916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef llvm::raw_pwrite_stream <a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Halide::Internal::LLVMOStream</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_l_l_v_m___output_8h_source.html#l00027">27</a> of file <a class="el" href="_l_l_v_m___output_8h_source.html">LLVM_Output.h</a>.</p>

</div>
</div>
<a class="anchor" id="af7acd6f64d4adf2c1b53c8931c3d0b87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#af7acd6f64d4adf2c1b53c8931c3d0b87">Halide::Internal::make_integer_sequence</a> = typedef typename <a class="el" href="struct_halide_1_1_internal_1_1make__integer__sequence__helper.html">make_integer_sequence_helper</a>&lt;T, 0, N&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00354">354</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac5d7a7bcb6b4a7de95e27c3234a36c68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t... Ints&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#ac5d7a7bcb6b4a7de95e27c3234a36c68">Halide::Internal::index_sequence</a> = typedef <a class="el" href="struct_halide_1_1_internal_1_1integer__sequence.html">integer_sequence</a>&lt;<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>, Ints...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00357">357</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a77432e592449f569978b6aabd58831f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#a77432e592449f569978b6aabd58831f0">Halide::Internal::make_index_sequence</a> = typedef <a class="el" href="namespace_halide_1_1_internal.html#af7acd6f64d4adf2c1b53c8931c3d0b87">make_integer_sequence</a>&lt;<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>, N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00360">360</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a8548315fd4d13ccebe45a8123369f7ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">Halide::Internal::Direction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a varying expression, try to find a constant that is either: An upper bound (always greater than or equal to the expression), or A lower bound (always less than or equal to the expression) If it fails, returns an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8548315fd4d13ccebe45a8123369f7caa19de5b94f7b83900d4b296d9fa491aec"></a>Upper&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8548315fd4d13ccebe45a8123369f7caab75fcdd2d72d9e000beab48622402d93"></a>Lower&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_bounds_8h_source.html#l00039">39</a> of file <a class="el" href="_bounds_8h_source.html">Bounds.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">Halide::Internal::IRNodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All our IR node types get unique IDs for the purposes of RTTI. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ad90896d6a515230ad67dfc865553e417"></a>IntImm&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a180c72f0a469e718cd8c2d23fb87ffb8"></a>UIntImm&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a42e91b555b80a7e354d5e43a9fc4be07"></a>FloatImm&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a771ef82b08c11e5688dcb0714a7bbc73"></a>StringImm&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a4cd9f3996d60790cd11c04f842ebc43c"></a>Cast&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a47c14840d8e15331fa420b9b2f757cd9"></a>Variable&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ae80155eceb940c89e2de63ad05868db2"></a>Sub&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a43d11850893d2fe84a1e618121c1cc0a"></a>Div&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a7aeb0277500c86e4aa6bd23f9a737942"></a>Mod&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a78d811e98514cd165dda532286610fd2"></a>Min&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a6a061313d22e51e0f25b7cd4dc065233"></a>Max&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a2dcbad7477fd40561e8b8198f173bd47"></a>EQ&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2adc33066c3993e0d50896e533fd692ce0"></a>NE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ac562607189d77eb9dfb707464c1e7b0b"></a>LT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2acfe6055d2e0503be378bb63449ec7ba6"></a>LE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2acd6a9bd2a175104eed40f0d33a8b4020"></a>GT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2af803729628adf4199f224c2a225038e9"></a>GE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ac33315685a0cba3ce53be378b3c7874b"></a>And&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a3a2d5fe857d8f9541136a124c2edec6c"></a>Or&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2aa74c05d080620f087c4e523977230666"></a>Not&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ae0626222614bdee31951d84c64e5e9ff"></a>Select&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2af19dbf2edb3a0bd74b0524d960ff21eb"></a>Load&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a99b4c3afc6aaa3ab4de17c90455a55eb"></a>Ramp&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2abe55b6387170df0ca68f41225268e842"></a>Broadcast&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ac3755e61202abd74da5885d2e9c9160e"></a>Call&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2acae6404c4aecf46684930fe2a86676a6"></a>Let&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2aa7312a9d08c50e9dbc7043efe7b54df2"></a>LetStmt&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a592a4f2501f4145b888a956d28448742"></a>AssertStmt&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a2c20d259c8ce0541078629d15be803a0"></a>ProducerConsumer&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a39e61d57e9209611edd4f884e9e47c11"></a>For&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2afdb0c388de01d545017cdf9ccf00eb72"></a>Store&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a2e5af173c7126a0e6f6bc996222386c7"></a>Provide&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ac9baacf6cca6c54626e594639081177f"></a>Allocate&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ab24ce0cd392a5b0b8dedc66c25213594"></a>Free&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2acbe1377636dc5dc95b68ff96203249cc"></a>Realize&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ae1e4c8c9ccd9fc39c391da4bcd093fb2"></a>Block&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2aaff6933d8331eca27edc911467980c9c"></a>IfThenElse&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ab086843368d1c92d0a86cbee76b20b6f"></a>Evaluate&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ae8b4b40ec3622e371789b790caabc083"></a>Shuffle&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a18540d940813866480eaca8d3f32d18e"></a>Prefetch&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00025">25</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">Halide::Internal::ForType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing a type of loop traversal. </p>
<p>Used in schedules, and in the <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> loop IR node. Serial is a conventional ordered for loop. Iterations occur in increasing order, and each iteration must appear to have finished before the next begins. Parallel, GPUBlock, and GPUThread are parallel and unordered: iterations may occur in any order, and multiple iterations may occur simultaneously. Vectorized and GPULane are parallel and synchronous: they act as if all iterations occur at the same time in lockstep. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a5255d3daaa0a6276b844d61401e6f493"></a>Serial&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a98402eecfbcefc336954458a01752131"></a>Parallel&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a138bc087eaaaf426b54f9a466f0cc725"></a>Vectorized&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1ae53597647de81f4cc9e098fc119ba0ac"></a>Unrolled&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a9ad52f412f8b405c833cd317db050a28"></a>GPUBlock&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a403672f982053243315d59e56d8a3b8d"></a>GPUThread&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1ab6f9478bd3fd1adac23a5802d786d642"></a>GPULane&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00384">384</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae02ee070dfadab621e55f3b3dd971e18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18">Halide::Internal::IOKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae02ee070dfadab621e55f3b3dd971e18af60357a8d17e45793298323f1b372a74"></a>Scalar&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261"></a>Function&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae02ee070dfadab621e55f3b3dd971e18a7e62bc342f41c946868f0ea6f0b712d8"></a>Buffer&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_generator_8h_source.html#l01080">1080</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a43770c59ec0f13935f4b33502ba7e817"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817">Halide::Internal::SyntheticParamType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a43770c59ec0f13935f4b33502ba7e817aa1fa27779242b4902f7ae3bdd5c6d508"></a>Type&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a43770c59ec0f13935f4b33502ba7e817a8ed64ce6e8032ddb62a463ffa78881d9"></a>Dim&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a43770c59ec0f13935f4b33502ba7e817a29216c809fd0a176cc9486ee7ee75e2c"></a>ArraySize&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_generator_8h_source.html#l02377">2377</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7dc0c8c1adc38d2c5a80979948f0007c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Halide::Internal::Monotonic</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7dc0c8c1adc38d2c5a80979948f0007cacb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7dc0c8c1adc38d2c5a80979948f0007caf3ff61f20d0c8eedfa348b0298df5edd"></a>Increasing&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7dc0c8c1adc38d2c5a80979948f0007ca2e6a9b0375c021e8f650a5eb22012b5b"></a>Decreasing&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7dc0c8c1adc38d2c5a80979948f0007ca88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_monotonic_8h_source.html#l00018">18</a> of file <a class="el" href="_monotonic_8h_source.html">Monotonic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acdd1e32e936b40a5ae1a2a1ef41b64c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_image_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert checks to make sure a statement doesn't read out of bounds on inputs or outputs, and that the inputs and outputs conform to the format required (e.g. </p>
<p>stride.0 must be 1). </p>

</div>
</div>
<a class="anchor" id="a6bd151298721810b82ac418d3810a0dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_parameter_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert checks to make sure that all referenced parameters meet their constraints. </p>

</div>
</div>
<a class="anchor" id="a576b07e3ec78cfaee39c3fb46180be89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::align_loads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to rewrite unaligned loads from buffers which are known to be aligned to instead load aligned vectors that cover the original load, and then slice the original load out of the aligned vectors. </p>

</div>
</div>
<a class="anchor" id="a410eac3ad68dfb697c5ee97100f2053f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::allocation_bounds_inference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes in terms of variables, and define values for those variables. </p>

</div>
</div>
<a class="anchor" id="afc30631d84b60819247acdc8d36a5069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_apply_split_result.html">ApplySplitResult</a>&gt; Halide::Internal::apply_split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim_extent_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> schedule on a definition (init or update), return a list of of predicates on the definition, substitutions that needs to be applied to the definition (in ascending order of application), and let stmts which defined the values of variables referred by the predicates and substitutions (ordered from innermost to outermost let). </p>

<p>Referenced by <a class="el" href="_apply_split_8h_source.html#l00038">Halide::Internal::ApplySplitResult::is_predicate()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ed1719a2195963da99bb290dface983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; &gt; Halide::Internal::compute_loop_bounds_after_split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> &amp;&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the loop bounds of the new dimensions resulting from applying the split schedules using the loop bounds of the old dimensions. </p>

<p>Referenced by <a class="el" href="_apply_split_8h_source.html#l00038">Halide::Internal::ApplySplitResult::is_predicate()</a>.</p>

</div>
</div>
<a class="anchor" id="a43db81cbccaa74354f14e7f902094ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a>&gt;&amp; Halide::Internal::get_ops_table </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exprs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_associative_ops_table_8h_source.html#l00059">Halide::Internal::AssociativePattern::commutative()</a>.</p>

</div>
</div>
<a class="anchor" id="acf049bd392c948b161c1435e23184a20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a> Halide::Internal::prove_associativity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an update definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> 'f', determine its equivalent associative binary/unary operator if there is any. </p>
<p>'is_associative' indicates if the operation was successfuly proven as associative. </p>

<p>Referenced by <a class="el" href="_associativity_8h_source.html#l00093">Halide::Internal::AssociativeOp::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a74a6050713d80d82d1ba201fc9f709b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::associativity_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_associativity_8h_source.html#l00093">Halide::Internal::AssociativeOp::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a976aabd7126fce7f9d7a46daeee8fd40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::inline_all_trivial_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the cost of computing a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> is about the same as calling the <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>, inline the <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. </p>
<p>Return true of any of the Funcs is inlined. </p>

<p>Referenced by <a class="el" href="_auto_schedule_8h_source.html#l00025">Halide::MachineParams::MachineParams()</a>.</p>

</div>
</div>
<a class="anchor" id="adb0e38c670066041490103529f6c5707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::inline_all_element_wise_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> if its values are only consumed by another single <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> in element-wise manner. </p>

<p>Referenced by <a class="el" href="_auto_schedule_8h_source.html#l00025">Halide::MachineParams::MachineParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a935bdff64b523568e228fde67dbc6f9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_estimates_on_outputs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all the pipeline outputs have estimates specified on each of their dimensions; otherwise, throw an assertion. </p>

<p>Referenced by <a class="el" href="_auto_schedule_8h_source.html#l00025">Halide::MachineParams::MachineParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a5840b87d513cf20f47e74eaf5b519d06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::generate_schedules </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_machine_params.html">MachineParams</a> &amp;&#160;</td>
          <td class="paramname"><em>arch_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate schedules for Funcs within a pipeline. </p>
<p>The Funcs should not already have specializations or schedules as the current auto-scheduler does not take into account user-defined schedules or specializations. This applies the schedules and returns a string representation of the schedules. The target architecture is specified by 'target'. </p>

<p>Referenced by <a class="el" href="_auto_schedule_8h_source.html#l00025">Halide::MachineParams::MachineParams()</a>.</p>

</div>
</div>
<a class="anchor" id="acdf8e17b611c700b1a41969a8dc7c1e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an int representation of 's'. </p>
<p>Throw an error on failure. </p>

</div>
</div>
<a class="anchor" id="a10382115757a18cd8ab8d674079ff4d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::subsitute_var_estimates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute every variable in an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> with its estimate if specified. </p>

</div>
</div>
<a class="anchor" id="a6fedcbbefe49e3df748c309938cf7f66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::subsitute_var_estimates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute every variable in an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> with its estimate if specified. </p>

</div>
</div>
<a class="anchor" id="a7f09ed39b20fb0f51fbda5a7b14c7f93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::get_extent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of an interval. </p>
<p>Return an undefined expr if the interval is unbounded. </p>

</div>
</div>
<a class="anchor" id="a09ce3144d60aa2f3abdb127b3750cb73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::box_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of an n-d box. </p>

</div>
</div>
<a class="anchor" id="a5f30fc5e0c64f2e3f32ffe1416f045b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::disp_regions </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to print the bounds of a region. </p>

</div>
</div>
<a class="anchor" id="a4cf44d2ab2c8eca7437d770011107830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> Halide::Internal::get_stage_definition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the corresponding definition of a function given the stage. </p>
<p>This will throw an assertion if the function is an extern function (Extern <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> does not have definition). </p>

</div>
</div>
<a class="anchor" id="a12964871a49b9d9eb81fb01991771150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a>&gt;&amp; Halide::Internal::get_stage_dims </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the corresponding loop dimensions of a function given the stage. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> extern <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>, this will return a list of size 1 containing the dummy __outermost loop dimension. </p>

</div>
</div>
<a class="anchor" id="a753561dbe4e01ef75c2af4ce17d3dfb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::combine_load_costs </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> partial load costs to the corresponding function in the result costs. </p>

</div>
</div>
<a class="anchor" id="af6adfe4d3a789e11392b6e58ee97ac64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> Halide::Internal::get_stage_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>pure_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the required bounds of an intermediate stage (f, stage_num) of function 'f' given the bounds of the pure dimensions. </p>

</div>
</div>
<a class="anchor" id="a4bf83d33d2ab27e489680b4680a12f66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a>&gt; Halide::Internal::get_stage_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#abff8dba5612d856cc2acfab99e3cf479">DimBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>pure_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the required bounds for all the stages of the function 'f'. </p>
<p>Each entry in the returned vector corresponds to a stage. </p>

</div>
</div>
<a class="anchor" id="a4b91c6f613e8875eda9c8ae063a86c0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::perform_inline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>inlines</em> = <code>std::set&lt;&#160;std::string&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively inline all the functions in the set 'inlines' into the expression 'e' and return the resulting expression. </p>

</div>
</div>
<a class="anchor" id="a5f6d082a8fe5678245509867a53372c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; Halide::Internal::get_parents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all functions that are directly called by a function stage (f, stage). </p>

</div>
</div>
<a class="anchor" id="a765c203107b702636e6f2cf5ba896f95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V Halide::Internal::get_element </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return value of element within a map. </p>
<p>This will assert if the element is not in the map. </p>

<p>Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00098">98</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

<p>References <a class="el" href="_error_8h_source.html#l00140">internal_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a525a46ec18d54c5534ccccc9e21ac262"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V&amp; Halide::Internal::get_element </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return value of element within a map. </p>
<p>This will assert if the element is not in the map. </p>

<p>Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00105">105</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

<p>References <a class="el" href="_error_8h_source.html#l00140">internal_assert</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a654878c752bfbc9f2aa979007ff80037">propagate_estimate_test()</a>.</p>

</div>
</div>
<a class="anchor" id="a654878c752bfbc9f2aa979007ff80037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::propagate_estimate_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_auto_schedule_utils_8h_source.html#l00105">get_element()</a>.</p>

</div>
</div>
<a class="anchor" id="a9191d3b3cba94302c0d08bf9f488d8c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::bounds_of_expr_in_scope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>const_bound</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values. ">Max</a> or min may be undefined expressions if the value is not bounded above or below. If the expression is a vector, also takes the bounds across the vector lanes and returns a scalar result.</p>
<p>This is for tasks such as deducing the region of a buffer loaded by a chunk of code. </p>

</div>
</div>
<a class="anchor" id="a69b9d67e1b22b876ec4e3f227557d835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::find_constant_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">Direction</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa34593e7612bf139260707200b6dacb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::find_constant_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find bounds for a varying expression that are either constants or +/-inf. </p>

</div>
</div>
<a class="anchor" id="ac2f62c0ee3ace8de2be57a9db369a3e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::merge_boxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand box a to encompass box b. </p>

</div>
</div>
<a class="anchor" id="ac9641dd947fdf6352ccd5e34548db35e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::boxes_overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if box a could possibly overlap box b. </p>

</div>
</div>
<a class="anchor" id="af86d8a9b260b097d115182e4b8488f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The union of two boxes. </p>

</div>
</div>
<a class="anchor" id="a8c57c8cff1c0ff811a01724b58086bdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The intersection of two boxes. </p>

</div>
</div>
<a class="anchor" id="a9198438916c78b87c90e665d665a18cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::box_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if box a provably contains box b. </p>

</div>
</div>
<a class="anchor" id="ab68083f9769cbbf033176ba50f3709c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression. </p>
<p>This is useful for figuring out what regions of things to evaluate. </p>

</div>
</div>
<a class="anchor" id="af1f12c0072dbbf9639829af1aedda4ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression. </p>
<p>This is useful for figuring out what regions of things to evaluate. </p>

</div>
</div>
<a class="anchor" id="aeaf945673dc90b8bdd2e79900b147954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_provided </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="ae6c4633706bdb6855b69fb9146ee65ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_provided </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="ae5c5855f4212c1cb3880a8534b6f41b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_touched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="a0fbd14233932a8f658ac66d45e00d7fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_touched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="a69980b5d1669ec54e78b7d393d8a7201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="aea6ad02cea8b0bacbb0b3c1f644af501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_required </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a0586fc0706c9a4d39f0ae5f9c7073c86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_provided </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a9d4d7463fc7d96132bbe01768f967dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_provided </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="aa211ee508998ef25191d04fa45eb16c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_touched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a35a819815a3d7f37a441a22c06689689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_touched </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a0b807d0d1524fb2f20b1533d05032c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> Halide::Internal::compute_function_value_bounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum and minimum possible value for each function in an environment. </p>

</div>
</div>
<a class="anchor" id="a439ef9127bf30f5e2a67963eb8db0323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::bounds_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab2369df82ba80121eb935e5ac7076de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::bounds_inference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>realization_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fused_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>environment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds. </p>

</div>
</div>
<a class="anchor" id="a7428f5e071a4f8c2d89a79afc6b426a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::bound_small_allocations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b58338c6b3553965f8360efe1d31788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::buffer_accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00495">Halide::Buffer&lt;&gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="aefca0281fde1b4caf8d1d188d4bd809d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;!std::is_convertible&lt;T, std::string&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00040">40</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00055">get_name_from_end_of_parameter_pack()</a>.</p>

</div>
</div>
<a class="anchor" id="ae3480ee712c4aecb9425a7e5c540889f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00044">44</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a016a8762a4f14a3d708461f0d1616bc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00048">48</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a70ab4586f42653c6b16a6e0ad186f1e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_name_from_end_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">First&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Second&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00055">55</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p>References <a class="el" href="_buffer_8h_source.html#l00040">get_name_from_end_of_parameter_pack()</a>.</p>

</div>
</div>
<a class="anchor" id="ab882d8987fcdb737d28066db1130b509"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_shape_from_start_of_parameter_pack_helper </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00059">59</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00073">get_shape_from_start_of_parameter_pack()</a>, and <a class="el" href="_buffer_8h_source.html#l00066">get_shape_from_start_of_parameter_pack_helper()</a>.</p>

</div>
</div>
<a class="anchor" id="a352d23994d86bd76a8167c6144f3a3dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_shape_from_start_of_parameter_pack_helper </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00062">62</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="afc82b2d635d098a40d4b87018edd0a73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_shape_from_start_of_parameter_pack_helper </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00066">66</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p>References <a class="el" href="_buffer_8h_source.html#l00059">get_shape_from_start_of_parameter_pack_helper()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7ed87b50654371fbd0e1415c8d52e4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; Halide::Internal::get_shape_from_start_of_parameter_pack </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_buffer_8h_source.html#l00073">73</a> of file <a class="el" href="_buffer_8h_source.html">Buffer.h</a>.</p>

<p>References <a class="el" href="_buffer_8h_source.html#l00059">get_shape_from_start_of_parameter_pack_helper()</a>.</p>

</div>
</div>
<a class="anchor" id="a5eefe960250b26cc13e38cb734803057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::canonicalize_gpu_vars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize GPU var names into some pre-determined block/thread names (i.e. </p>
<p>__block_id_x, __thread_id_x, etc.). The x/y/z/w order is determined by the nesting order: innermost is assigned to x and so on. </p>

</div>
</div>
<a class="anchor" id="a1a1e270066706802bc3903a17703f173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType* Halide::Internal::build_closure_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StructType *&#160;</td>
          <td class="paramname"><em>buffer_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The llvm type of a struct containing all of the externally referenced state of a <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures. ">Closure</a>. </p>

</div>
</div>
<a class="anchor" id="adf3a7858581f388f494393f77364e53a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::pack_closure </td>
          <td>(</td>
          <td class="paramtype">llvm::StructType *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StructType *&#160;</td>
          <td class="paramname"><em>buffer_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt; llvm::ConstantFolder, llvm::IRBuilderDefaultInserter &gt; *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that builds a struct containing all the externally referenced state. </p>
<p>Requires you to pass it a type and struct to fill in, a scope to retrieve the llvm values from and a builder to place the packing code. </p>

</div>
</div>
<a class="anchor" id="a0822c4fa8fbb5790406eb22d2d5849ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::unpack_closure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StructType *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt; llvm::ConstantFolder, llvm::IRBuilderDefaultInserter &gt; *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that unpacks a struct containing all the externally referenced state into a symbol table. </p>
<p>Requires you to pass it a state struct type and value, a scope to fill, and a builder to place the unpacking code. </p>

</div>
</div>
<a class="anchor" id="a71f10140e29131153c3be98d2899b090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#a43770c59ec0f13935f4b33502ba7e817aa1fa27779242b4902f7ae3bdd5c6d508">llvm::Type</a>* Halide::Internal::llvm_type_of </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the llvm type equivalent to a given halide type. </p>

<p>Referenced by <a class="el" href="_code_gen___l_l_v_m_8h_source.html#l00371">Halide::Internal::CodeGen_LLVM::prepare_for_early_exit()</a>.</p>

</div>
</div>
<a class="anchor" id="adc60421b682a09ea4c4dcaaaa3e105e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::function_takes_user_context </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Which built-in functions require a user-context first argument? </p>

</div>
</div>
<a class="anchor" id="a4abe6b887804e86f403f0af16d5a2ba1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_allocation_fit_on_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a size (in bytes), return True if the allocation size can fit on the stack; otherwise, return False. </p>
<p>This routine asserts if size is non-positive. </p>

</div>
</div>
<a class="anchor" id="ab7a4f18b650b23e1e6ed980d1feebcf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_euclidean_div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a class="anchor" id="ae81d78fd7f3115750e17167ebf0fe920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_euclidean_mod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a class="anchor" id="a83ab4b5f40c8220a917723d3fe46d736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unpredicate_loads_stores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace predicated loads/stores with unpredicated equivalents inside branches. </p>

</div>
</div>
<a class="anchor" id="a7b4fa94b1f3a877eb3387824c09df826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_target_options </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::TargetOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>mcpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>mattrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an llvm::Module, set llvm:TargetOptions, cpu and attr information. </p>

</div>
</div>
<a class="anchor" id="a1b16d175882e16f544bf4bf92ec931b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::clone_target_options </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two llvm::Modules, clone target options from one to the other. </p>

</div>
</div>
<a class="anchor" id="af1e20aff45028d266f854487159df341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::TargetMachine&gt; Halide::Internal::make_target_machine </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an llvm::Module, get or create an llvm:TargetMachine. </p>

</div>
</div>
<a class="anchor" id="abfe55211c4dbc852f29c8e764360c670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::set_function_attributes_for_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261">llvm::Function</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the appropriate llvm <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> attributes given a <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

</div>
</div>
<a class="anchor" id="a9170638fdb8e1cb975e1ff7fb561a560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::cplusplus_function_mangled_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>return_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the mangled C++ name for a function. </p>
<p>The target parameter is used to decide on the C++ ABI/mangling style to use. </p>

</div>
</div>
<a class="anchor" id="a67d63fc361474a95f58c2839461cc7df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::cplusplus_mangle_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f2af44447b9269918e9d63d948ea8bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::common_subexpression_elimination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lift_all</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable. </p>
<p>This is important to do within <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> (instead of punting to llvm), because exprs that come in from the front-end are small when considered as a graph, but combinatorially large when considered as a tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> an example of a such a case, see test/code_explosion.cpp</p>
<p>The last parameter determines whether all common subexpressions are lifted, or only those that the simplifier would not subsitute back in (e.g. addition of a constant). </p>

</div>
</div>
<a class="anchor" id="ac03dcb48bcb8e81238a1c6cfea195e1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::common_subexpression_elimination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lift_all</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do common-subexpression-elimination on each expression in a statement. </p>
<p>Does not introduce let statements. </p>

</div>
</div>
<a class="anchor" id="a88cbc086e9926046bdb9f4ade681111a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::cse_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab98f0a702bd775e67baed5bcd986ae27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide statement on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a029791644c90ea7a194d58fc87ab41bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function. ">LoweredFunc</a> in a human readable format. </p>

</div>
</div>
<a class="anchor" id="a380f859ef78573f0f630f6ca2a392e6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::debug_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects debug prints in a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function. ">LoweredFunc</a> that describe the arguments. </p>
<p>Mutates the given func. </p>

</div>
</div>
<a class="anchor" id="aaea2b563fa94726a65b596979b9d2f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::debug_to_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes still unlowered. </p>
<p>If the corresponding functions have a debug_file set, then inject code that will dump the contents of those functions to a file after the realization. </p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01034">Halide::Func::add_custom_lowering_pass()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa9b678f3916b022dd8b8415c9ca0750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_odd_lanes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the odd-numbered lanes in a vector. </p>

</div>
</div>
<a class="anchor" id="a017315ab942e526e9915325f05d406a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_even_lanes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the even-numbered lanes in a vector. </p>

</div>
</div>
<a class="anchor" id="a750c306ff019e4f332238799979c9345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_lane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the nth lane of a vector. </p>

</div>
</div>
<a class="anchor" id="ac1233a717a83d74121106b95245ce81a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::rewrite_interleavings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic. </p>

</div>
</div>
<a class="anchor" id="a8dc1b0ff156c8b0ca5fd26956ee482a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::deinterleave_vector_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b09a9a7a36079688446d7d49dd2f901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::derivative_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5dd8e9020c7517c9cce8212ec8660561"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::has_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if expr depends on the variable. </p>

</div>
</div>
<a class="anchor" id="a599ceaaeeb259fa775831b46da41c66b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::has_let_defined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if expr has a <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language. ">Let</a> operation defining the variable. </p>

</div>
</div>
<a class="anchor" id="aa8d3c39b97b822e2c3e50a1c977441aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::remove_let_definitions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all let definitions of expr. </p>

</div>
</div>
<a class="anchor" id="ae8c4e4e271de96594d3b461a3255f4bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Halide::Internal::gather_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of variables that expr depends on and are in the filter. </p>

</div>
</div>
<a class="anchor" id="a3fb392e8cddbe26a58fd90ed22cd173b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Halide::Internal::gather_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aed831839271449ac11b2cadb24003e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a>&gt; Halide::Internal::gather_rvariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9113ee099078cd921abc0b6151e5669e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable_info.html">ReductionVariableInfo</a>&gt; Halide::Internal::gather_rvariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b66032c9826d25bfa470c4c974081d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::add_let_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>let_var_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>let_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> necessary let expressions to expr. </p>

</div>
</div>
<a class="anchor" id="a8422615887974b7d347d7b069e592ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; Halide::Internal::sort_expressions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Topologically sort the expression graph expressed by expr. </p>

</div>
</div>
<a class="anchor" id="ace9cd05798adb83f7286b3d0d0789d55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::inference_bounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_halide_1_1_internal.html#a9ee415bddc2cb4a392f5411485d740d0">FuncBounds</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the bounds of funcs. </p>

</div>
</div>
<a class="anchor" id="af8109bfe3edb53d92d18c7cea459d837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::inference_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#a9ee415bddc2cb4a392f5411485d740d0">FuncBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>output_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abeff30be2f05a33246906cb93c5ef840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; &gt; Halide::Internal::box_to_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> <a class="el" href="struct_halide_1_1_internal_1_1_box.html" title="Represents the bounds of a region of arbitrary dimension. ">Box</a> to vector of (min, extent) </p>

</div>
</div>
<a class="anchor" id="a44d062e9354cd14001f47cd01e82b93a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if bounds0 and bounds1 represent the same bounds. </p>

<p>Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00098">Halide::Internal::ExprWithCompareCache::ExprWithCompareCache()</a>, <a class="el" href="_associative_ops_table_8h_source.html#l00046">Halide::Internal::AssociativePattern::operator==()</a>, and <a class="el" href="_associativity_8h_source.html#l00071">Halide::Internal::AssociativeOp::Replacement::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e35493cbdbaecbf87027d1b3474a5b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Halide::Internal::vars_to_strings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of variable names. </p>

</div>
</div>
<a class="anchor" id="a96c20a455c5f2aed48623d012438b99d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a> Halide::Internal::extract_rdom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the reduction domain used by expr. </p>

</div>
</div>
<a class="anchor" id="ab3c553025a28a2d63ed43f8875bf4c18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; Halide::Internal::solve_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expr is new_var == f(var), solve for var == g(new_var) if multiple new_var correponds to same var, introduce a <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> </p>

</div>
</div>
<a class="anchor" id="aa387850d541b7adbe48dffdcc68e1abf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_buffer_info.html">BufferInfo</a>&gt; Halide::Internal::find_buffer_calls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac4fde1293038bd9c9f0dddde5afdccca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; Halide::Internal::find_implicit_variables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all implicit variables in expr. </p>

</div>
</div>
<a class="anchor" id="aea7c0a6c9d1ffb171d4343876021f604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_rdom_predicate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the variable. </p>
<p>Also replace all occurence in rdom.where() predicates. </p>

</div>
</div>
<a class="anchor" id="a4b228248e212d4e140a3b7499f65a8c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_calling_function </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>let_var_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if expr contains call to func_name. </p>

</div>
</div>
<a class="anchor" id="add1be017ee388aad7a1cb19fa653e300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_calling_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>let_var_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if expr depends on any function or buffer. </p>

</div>
</div>
<a class="anchor" id="a1f206e59b95e0f061e7bc235f1759e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_device_interface_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> which evaluates to the device interface for the given device api at runtime. </p>

</div>
</div>
<a class="anchor" id="a5aedffca433bdfab639e4956779040e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_early_frees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation. </p>
<p>Targets may use this to free buffers earlier than the close of their <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a> node. </p>

</div>
</div>
<a class="anchor" id="a13202cdbaa52c465421a8bcfda356d9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::eliminate_bool_vectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, instead of select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8, u16x8, u16x8), where the first argument is a vector of integers representing a mask. This pass converts vectors of bools to vectors of integers to meet this requirement. This is done by injecting intrinsics to convert bools to architecture-specific masks, and using a select_mask instrinsic instead of a <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator. ">Select</a> node. Because the masks are architecture specific, they may not be stored or loaded. On Stores, the masks are converted to UInt(8) with a value of 0 or 1, which is our canonical in-memory representation of a bool. </p>

</div>
</div>
<a class="anchor" id="a1bb97941d92283c2daa7075a5db09bfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::eliminate_bool_vectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, instead of select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8, u16x8, u16x8), where the first argument is a vector of integers representing a mask. This pass converts vectors of bools to vectors of integers to meet this requirement. This is done by injecting intrinsics to convert bools to architecture-specific masks, and using a select_mask instrinsic instead of a <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator. ">Select</a> node. Because the masks are architecture specific, they may not be stored or loaded. On Stores, the masks are converted to UInt(8) with a value of 0 or 1, which is our canonical in-memory representation of a bool. </p>

</div>
</div>
<a class="anchor" id="a0747a9e54d0da5a37c1530162121942f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Internal::eliminated_bool_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>bool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>other_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a type is a boolean vector, find the type that it has been changed to by eliminate_bool_vectors. </p>

<p>Definition at line <a class="el" href="_eliminate_bool_vectors_8h_source.html#l00032">32</a> of file <a class="el" href="_eliminate_bool_vectors_8h_source.html">EliminateBoolVectors.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00312">Halide::Type::bits()</a>, <a class="el" href="_type_8h_source.html#l00274">Halide::Type::Int</a>, <a class="el" href="_type_8h_source.html#l00343">Halide::Type::is_vector()</a>, <a class="el" href="_type_8h_source.html#l00324">Halide::Type::with_bits()</a>, and <a class="el" href="_type_8h_source.html#l00318">Halide::Type::with_code()</a>.</p>

</div>
</div>
<a class="anchor" id="a41efaa6fd3f0ef81666337a4ca0aef9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; <a class="el" href="namespace_halide_1_1_internal.html#a591b432e75725e61702af6b05d7c9d76">Halide::Internal::ref_count</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00102">102</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad3d80243a2f3de47f613df12b48475c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a11ca920b642ef490aeac2b4e864d6254">Halide::Internal::destroy</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00105">105</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="af29840c52385c687d17608300c94a0ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StmtOrExpr , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_or_expr_uses_vars </td>
          <td>(</td>
          <td class="paramtype">StmtOrExpr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a statement or expression references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00055">55</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_uses_var_8h_source.html#l00047">Halide::Internal::ExprUsesVars&lt; T &gt;::result</a>.</p>

<p>Referenced by <a class="el" href="_expr_uses_var_8h_source.html#l00097">expr_uses_vars()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00107">stmt_uses_vars()</a>.</p>

</div>
</div>
<a class="anchor" id="aaade6cc73ce3cd9902f445c135a0226d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StmtOrExpr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_or_expr_uses_var </td>
          <td>(</td>
          <td class="paramtype">StmtOrExpr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a statement or expression references the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00067">67</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_scope_8h_source.html#l00163">Halide::Internal::Scope&lt; T &gt;::push()</a>.</p>

<p>Referenced by <a class="el" href="_expr_uses_var_8h_source.html#l00078">expr_uses_var()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00087">stmt_uses_var()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5f21194a1d0e54add9a15a79eb889dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_uses_var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an expression references the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00078">78</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_uses_var_8h_source.html#l00067">stmt_or_expr_uses_var()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7f70cf57af5925647346a8e1f3a8268"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_uses_var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a statement references the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00087">87</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_uses_var_8h_source.html#l00067">stmt_or_expr_uses_var()</a>.</p>

</div>
</div>
<a class="anchor" id="af9bc2cef7dff2305a29dc5512a7542da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_uses_vars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an expression references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00097">97</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_uses_var_8h_source.html#l00055">stmt_or_expr_uses_vars()</a>.</p>

</div>
</div>
<a class="anchor" id="a69aa39cfbbd5a1aead3e742c4fc0048a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_uses_vars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a statement references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00107">107</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_uses_var_8h_source.html#l00055">stmt_or_expr_uses_vars()</a>.</p>

</div>
</div>
<a class="anchor" id="a16b42e90ad180f1254cdd3be0ae7be89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::find_direct_calls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> extents. </p>
<p>This map <em>does not</em> include the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, unless it is called recursively by itself. </p>

</div>
</div>
<a class="anchor" id="a770da2a7374eb2a8ac60f5c9d90b88ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::find_transitive_calls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, or indirectly in those functions' definitions, recursively. </p>
<p>This map always <em>includes</em> the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f. </p>

</div>
</div>
<a class="anchor" id="a896238d54e6f7d94171698d1c4296b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::populate_environment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all Functions transitively referenced by f in any way and add them to the given map. </p>

</div>
</div>
<a class="anchor" id="a4b98bf6f8f3475caaa691d7884a31d45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Last &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l02305">2305</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="_error_8h_source.html#l00141">user_assert</a>.</p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l02350">Halide::evaluate()</a>, and <a class="el" href="_func_8h_source.html#l02396">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="abec0560d55ceb7384483f00da38ad73f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l02314">2314</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a class="anchor" id="a32bce2836846aa0286859b005b6aa015"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Last &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assign_results </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l02320">2320</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l02350">Halide::evaluate()</a>, and <a class="el" href="_func_8h_source.html#l02396">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="acdc822256984ddc07c031b230ce2b8ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assign_results </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">First&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Second&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l02326">2326</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1f9bfb55aa0058e51d72037fde785fb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::schedule_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l02362">2362</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">Halide::get_jit_target_from_environment()</a>, <a class="el" href="class_halide_1_1_func.html#ad622b7218b4a44fea6823cc0ae81c092">Halide::Func::gpu_single_thread()</a>, <a class="el" href="struct_halide_1_1_target.html#acbbcbe93a4d5ee7f9f93c6b3d7914bf3">Halide::Target::has_feature()</a>, <a class="el" href="struct_halide_1_1_target.html#a653f58c7d0efbd7dac22cf239576a660">Halide::Target::has_gpu_feature()</a>, <a class="el" href="class_halide_1_1_func.html#a41a2a45d0610490eec14516def1d0446">Halide::Func::hexagon()</a>, <a class="el" href="_target_8h_source.html#l00081">Halide::Target::HVX_128</a>, and <a class="el" href="_target_8h_source.html#l00080">Halide::Target::HVX_64</a>.</p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l02380">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="aad946e0645ead551baee06d6c39e6552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt;, std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; &gt; Halide::Internal::deep_copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep copy an entire <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> DAG. </p>

<p>Referenced by <a class="el" href="_schedule_8h_source.html#l00377">Halide::Internal::FuncSchedule::FuncSchedule()</a>, <a class="el" href="_function_8h_source.html#l00095">Halide::Internal::Function::get_contents()</a>, <a class="el" href="_function_8h_source.html#l00271">Halide::Internal::Function::operator ExternFuncArgument()</a>, and <a class="el" href="_reduction_8h_source.html#l00046">Halide::Internal::ReductionDomain::ReductionDomain()</a>.</p>

</div>
</div>
<a class="anchor" id="a318c3eca91038227e115e5440d687c43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::zero_gpu_loop_mins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite all GPU loops to have a min of zero. </p>

</div>
</div>
<a class="anchor" id="a0081752824625e87b5e95bfae979499f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fuse_gpu_thread_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s GPGPU IR to the OpenCL/CUDA/Metal model. </p>
<p>Within every loop over gpu block indices, fuse the inner loops over thread indices into a single loop (with predication to turn off threads). Also injects synchronization points as needed, and hoists allocations at the block level out into a single shared memory array. </p>

</div>
</div>
<a class="anchor" id="a56a15fc4880c65ae27434a924540a07e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fuzz_float_stores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On every store of a floating point value, mask off the least-significant-bit of the mantissa. </p>
<p>We've found that whether or not this dramatically changes the output of a pipeline correlates very well with whether or not a pipeline will produce very different outputs on different architectures (e.g. with and without FMA). It's also a useful way to detect bad tests, such as those that expect exact floating point equality across platforms. </p>

</div>
</div>
<a class="anchor" id="ac4be7daed1a8c6cd914be946f22ea4df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::generator_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_generator_8h_source.html#l03174">Halide::Generator&lt; T &gt;::call_schedule()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2672948a0299d09a067ec4dbb862723"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; Halide::Internal::parameter_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_generator_8h_source.html#l00281">Halide::Internal::ValueTracker::ValueTracker()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b54f450e1cd03c240743907e45487ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::string Halide::Internal::enum_to_string </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>enum_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l00288">288</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p>References <a class="el" href="_error_8h_source.html#l00136">user_error</a>.</p>

<p>Referenced by <a class="el" href="_generator_8h_source.html#l00792">Halide::Internal::GeneratorParam_Enum&lt; T &gt;::get_default_value()</a>, and <a class="el" href="_generator_8h_source.html#l00306">halide_type_to_enum_string()</a>.</p>

</div>
</div>
<a class="anchor" id="afd2308d89d4a9b9eef0803e92c383b0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::enum_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>enum_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l00299">299</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#aebb90b52661557ff81407bc45cbdf3e6">get_halide_type_enum_map()</a>, and <a class="el" href="_error_8h_source.html#l00141">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="aebb90b52661557ff81407bc45cbdf3e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&gt;&amp; Halide::Internal::get_halide_type_enum_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_generator_8h_source.html#l00299">enum_from_string()</a>, and <a class="el" href="_generator_8h_source.html#l00306">halide_type_to_enum_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a2cc7c793b324e02e15a109f1e8af548c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::halide_type_to_enum_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l00306">306</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p>References <a class="el" href="_generator_8h_source.html#l00288">enum_to_string()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd">generate_filter_main()</a>, <a class="el" href="namespace_halide_1_1_internal.html#aebb90b52661557ff81407bc45cbdf3e6">get_halide_type_enum_map()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a600136fc73541f81f75ee07095a62025">halide_type_to_c_source()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a9e8f71298de4ece7dc2e59ae811c3fd2">halide_type_to_c_type()</a>.</p>

</div>
</div>
<a class="anchor" id="a600136fc73541f81f75ee07095a62025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::halide_type_to_c_source </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_generator_8h_source.html#l00836">Halide::Internal::GeneratorParam_Type&lt; T &gt;::get_default_value()</a>, and <a class="el" href="_generator_8h_source.html#l00306">halide_type_to_enum_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e8f71298de4ece7dc2e59ae811c3fd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::halide_type_to_c_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_generator_8h_source.html#l01448">Halide::Internal::GeneratorInput_Buffer&lt; T &gt;::get_c_type()</a>, <a class="el" href="_generator_8h_source.html#l02123">Halide::Internal::GeneratorOutput_Buffer&lt; T &gt;::get_c_type()</a>, and <a class="el" href="_generator_8h_source.html#l00306">halide_type_to_enum_string()</a>.</p>

</div>
</div>
<a class="anchor" id="ad032a99a32ca261c475b4335ece416dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::generate_filter_main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>cerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal.html#ad032a99a32ca261c475b4335ece416dd" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#aab480390a9681797693f2c8c9b867013">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation. </p>

<p>Referenced by <a class="el" href="_generator_8h_source.html#l00306">halide_type_to_enum_string()</a>.</p>

</div>
</div>
<a class="anchor" id="ae47fa4b8f49636c214b214f5d0f4ed34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::parse_scalar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l02367">2367</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a7682395f90f7229826df771f8c286fac">parse_halide_type_list()</a>, and <a class="el" href="_error_8h_source.html#l00141">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a7682395f90f7229826df771f8c286fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_type.html">Type</a>&gt; Halide::Internal::parse_halide_type_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_generator_8h_source.html#l02367">parse_scalar()</a>.</p>

</div>
</div>
<a class="anchor" id="a8696c48228f0cb335255ae46954909e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_hexagon_rpc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>host_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pull loops marked with the Hexagon device API to a separate module, and call them through the Hexagon host runtime module. </p>

</div>
</div>
<a class="anchor" id="a55a0c1dd9c3f33e07eb6df7b59850286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;<a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>&gt; Halide::Internal::compile_module_to_hexagon_shared_object </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>device_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a23028986d4f21dce50037af81288d511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::optimize_hexagon_shuffles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lut_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace indirect and other loads with simple loads + vlut calls. </p>

</div>
</div>
<a class="anchor" id="a7a253a99e9c356e4f91110a986d33cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::vtmpy_generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate vtmpy instruction if possible. </p>

</div>
</div>
<a class="anchor" id="ae00dade7d363c80cd56af5987be8c93d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::optimize_hexagon_instructions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hexagon deinterleaves when performing widening operations, and interleaves when performing narrowing operations. </p>
<p>This pass rewrites widenings/narrowings to be explicit in the IR, and attempts to simplify away most of the interleaving/deinterleaving. </p>

</div>
</div>
<a class="anchor" id="a6b45ec55494eb56aa834b6df8ab6f095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::native_deinterleave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate deinterleave or interleave operations, operating on groups of vectors at a time. </p>

</div>
</div>
<a class="anchor" id="a8f57cdbcddfbe9985a1d491c5f2de087"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::native_interleave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate deinterleave or interleave operations, operating on groups of vectors at a time. </p>

</div>
</div>
<a class="anchor" id="a90c6471944a1cc0064f3c6aed326a3d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_native_deinterleave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate deinterleave or interleave operations, operating on groups of vectors at a time. </p>

</div>
</div>
<a class="anchor" id="af6dfa8a0a83f7b7e41c320186093847c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_native_interleave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate deinterleave or interleave operations, operating on groups of vectors at a time. </p>

</div>
</div>
<a class="anchor" id="a528f74485df2d7be5b5fc9e2c8bc51b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_inferred_argument.html">InferredArgument</a>&gt; Halide::Internal::infer_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_pipeline_8h_source.html#l00375">Halide::Pipeline::add_custom_lowering_pass()</a>, <a class="el" href="_func_8h_source.html#l02283">Halide::Func::operator ExternFuncArgument()</a>, and <a class="el" href="_infer_arguments_8h_source.html#l00029">Halide::Internal::InferredArgument::operator&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a50f932b31fe791a7b2002b829c8e5364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::call_extern_and_assert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper function to call an extern function, and assert that it returns 0. </p>

</div>
</div>
<a class="anchor" id="a9fa15ced2f13142e6c4b5e5f4649aa15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_host_dev_buffer_copies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject calls to halide_device_malloc, halide_copy_to_device, and halide_copy_to_host as needed. </p>

</div>
</div>
<a class="anchor" id="a94843d09c24cd65c12aa022e0ae3bb70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_opengl_intrinsics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for kernel for loops and turn loads and stores inside the loops into OpenGL texture load and store intrinsics. </p>
<p>Should only be run when the OpenGL target is active. </p>

</div>
</div>
<a class="anchor" id="a846846d97dbb9c2db23a476126163645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a single named function, which must be pure. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> a pure function to be inlined, it must not have any specializations (i.e. it can only have one values definition). </p>

</div>
</div>
<a class="anchor" id="a74d4d98216185149bb2d834223dde889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a single named function, which must be pure. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> a pure function to be inlined, it must not have any specializations (i.e. it can only have one values definition). </p>

</div>
</div>
<a class="anchor" id="ab1534ff08ab7d94326aac9f617591156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a single named function, which must be pure. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> a pure function to be inlined, it must not have any specializations (i.e. it can only have one values definition). </p>

</div>
</div>
<a class="anchor" id="ab6883343b90964967cb0bafb2551f5c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::validate_schedule_inlined_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the schedule of an inlined function is legal, throwing an error if it is not. </p>

</div>
</div>
<a class="anchor" id="ad703cfb8d8fe0305a282b71a8824303a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::interval_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_interval_8h_source.html#l00082">Halide::Internal::Interval::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a591b432e75725e61702af6b05d7c9d76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; Halide::Internal::ref_count </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

<p>Referenced by <a class="el" href="_intrusive_ptr_8h_source.html#l00025">Halide::Internal::RefCount::is_zero()</a>.</p>

</div>
</div>
<a class="anchor" id="a11ca920b642ef490aeac2b4e864d6254"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::destroy </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

<p>Referenced by <a class="el" href="_intrusive_ptr_8h_source.html#l00025">Halide::Internal::RefCount::is_zero()</a>.</p>

</div>
</div>
<a class="anchor" id="a1074fbd76b40a9cc210fbd22fdcda914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a>. If you're comparing non-CSE'd Exprs, use graph_equal, which is safe for nasty graphs of IR nodes. </p>

</div>
</div>
<a class="anchor" id="a705ef4763a82b7907112099a01604d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a>. If you're comparing non-CSE'd Exprs, use graph_equal, which is safe for nasty graphs of IR nodes. </p>

</div>
</div>
<a class="anchor" id="a3fad2884f65d9bbb20c6cdcc65e08d47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::graph_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a>. If you're comparing non-CSE'd Exprs, use graph_equal, which is safe for nasty graphs of IR nodes. </p>

<p>Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00098">Halide::Internal::ExprWithCompareCache::ExprWithCompareCache()</a>.</p>

</div>
</div>
<a class="anchor" id="a31b5e9d7137c035d913570030d474bac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::graph_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a>. If you're comparing non-CSE'd Exprs, use graph_equal, which is safe for nasty graphs of IR nodes. </p>

</div>
</div>
<a class="anchor" id="ac59065f04bcf4e664007d95affa7ce3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::ir_equality_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00098">Halide::Internal::ExprWithCompareCache::ExprWithCompareCache()</a>.</p>

</div>
</div>
<a class="anchor" id="af22936be5f74cc50d73a4e478bd9271e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument. </p>
<p>Wildcards require the types to match. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> the type bits and width, a 0 indicates "match anything". So an Int(8, 0) will match 8-bit integer vectors of any width (including scalars), and a UInt(0, 0) will match any unsigned integer type.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example: </p><div class="fragment"><div class="line">Expr x = <a class="code" href="struct_halide_1_1_internal_1_1_variable.html#abf38bc7c87ec8fdc8dabad8eebf2939c">Variable::make</a>(<a class="code" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a>(32), <span class="stringliteral">&quot;*&quot;</span>);</div><div class="line">match(x + x, 3 + (2*k), result)</div></div><!-- fragment --><p> should return true, and set result[0] to 3 and result[1] to 2*k. </p>

</div>
</div>
<a class="anchor" id="a90cc40f5fe9cc4d0ba0bf37b5550ad01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables are matched consistently. </p>
<p>The first time a variable is matched, it assumes the value of the matching part of the second expression. Subsequent matches must be equal to the first match.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example: </p><div class="fragment"><div class="line">Var x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line">match(x*(x + y), <a class="code" href="namespace_halide_1_1_runtime_1_1_internal.html#a67dd017542dcaa40f1181f7806bd18af">a</a>*(<a class="code" href="namespace_halide_1_1_runtime_1_1_internal.html#a67dd017542dcaa40f1181f7806bd18af">a</a> + b), result)</div></div><!-- fragment --><p> should return true, and set result["x"] = a, and result["y"] = b. </p>

</div>
</div>
<a class="anchor" id="a1eed932bc0eb3a15edcb20795bfb8c2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::expr_match_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af11d0eaaf5222de9d1151bf81479beb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants. ">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node. ">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same. </p>
<p>Doesn't do any constant folding. </p>

<p>Referenced by <a class="el" href="_type_8h_source.html#l00194">halide_handle_cplusplus_type::make()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0438766d0040aa39c5f420f1a92b01b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same. </p>

</div>
</div>
<a class="anchor" id="a98f803a9899cc2d96a93179dba4bf21f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>* Halide::Internal::as_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, return a pointer to its value. </p>
<p>Otherwise returns nullptr. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00211">Halide::cast()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01204">Halide::fast_pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01534">Halide::lerp()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01160">Halide::pow()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2c472a5cc4013b179510625b02bf6d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>* Halide::Internal::as_const_uint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a>, return a pointer to its value. </p>
<p>Otherwise returns nullptr. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00211">Halide::cast()</a>.</p>

</div>
</div>
<a class="anchor" id="a6252d95fc57aad0465caf882eded56bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* Halide::Internal::as_const_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, return a pointer to its value. </p>
<p>Otherwise returns nullptr. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00211">Halide::cast()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01534">Halide::lerp()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5f2b30c213250c3ba20c4d211f5b00f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_const_power_of_two_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a constant integer power of two. </p>
<p>Also returns log base two of the expression if it is. Only returns true for integer types. </p>

</div>
</div>
<a class="anchor" id="a5f26b6233cff17bdbf097bfe981e096c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_positive_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="a0e57c1aaa1719ed42fac6dc6661ebe90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_negative_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="a3204e449a3ad9f0b1377539764da59a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_negative_negatable_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) and is its negative value representable. </p>
<p>(This excludes the most negative value of the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s type from inclusion. Intended to be used when the value will be negated as part of simplification.) </p>

</div>
</div>
<a class="anchor" id="a0eb4bb1c7164222794e270f58c428eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_undef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression an undef. </p>

</div>
</div>
<a class="anchor" id="a417121e0d1b13f7f5a864091388ca048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression) </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00423">Halide::operator%()</a>.</p>

</div>
</div>
<a class="anchor" id="a83157c92372f583e993d653d27b967a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression) </p>

<p>Referenced by <a class="el" href="_bounds_8h_source.html#l00068">Halide::Internal::Box::maybe_unused()</a>.</p>

</div>
</div>
<a class="anchor" id="a32e4631b054fafe0883781e00b77a5ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_two </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="a916dccb9f4ad5763ce86721ab3187cfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_no_op </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> node of a constant) </p>

</div>
</div>
<a class="anchor" id="a8325254f314a3811cc5ebebf4497466d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_pure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the expression 1) Take on the same value no matter where it appears in a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, and 2) Evaluating it has no side-effects. </p>

</div>
</div>
<a class="anchor" id="a5a057ef6ceb8462dbca18eb9020bc297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00211">Halide::cast()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00091">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00705">Halide::max()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00752">Halide::min()</a>, <a class="el" href="_generator_8h_source.html#l00457">Halide::Internal::GeneratorParamImpl&lt; LoopLevel &gt;::operator Expr()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00619">Halide::operator!=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00433">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00348">Halide::operator*()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00261">Halide::operator+()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00299">Halide::operator-()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00400">Halide::operator/()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00495">Halide::operator&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01427">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00526">Halide::operator&lt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00588">Halide::operator==()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00464">Halide::operator&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00557">Halide::operator&gt;=()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01456">Halide::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a69927d11c0fe7c6cf4092a811f6676d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

</div>
</div>
<a class="anchor" id="ad3a72bc2d5b95e6a43e803a9f7c4acea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

</div>
</div>
<a class="anchor" id="aaae8ca905f0ce9cde74cc0897a61c4e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00091">91</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a70b64c00a450c92807011cdc02f8b29b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00092">92</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a4df9ef655a78f9fb233fa0322525496c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00093">93</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="af14e2dade91eb04482b4b5ffdfc920dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00094">94</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a5231b80b8e1a7904cdd4fcac7b89a98d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00095">95</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9a1ece36d20a64a59c92bf7f8c4e9aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00096">96</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="addbd965eccbcfc1f5b80eaa0607f698c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00097">97</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="aa90929bcfb18413ffd527152bb8580de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00098">98</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a6592ef00a06a1d8f017b48359099c16d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1float16__t.html">float16_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00099">99</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00190">Halide::Runtime::Internal::a</a>, <a class="el" href="runtime__internal_8h_source.html#l00188">Halide::Runtime::Internal::b</a>, <a class="el" href="namespace_halide_1_1_internal.html#a2de10096d923cdc0f02582981b718854">check_representable()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab94c84e726218144cf4c5d3a08b38f8d">const_false()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a5fb413640f7f46493733fa33d95ea9fc">const_true()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a0c1307e62672d75c2f542f37430b3239">halide_erf()</a>, <a class="el" href="namespace_halide_1_1_internal.html#af0b9fcbf1259db14123bffa40c5bae56">halide_exp()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a1953dca5a0981d186fc050a1deace06b">halide_log()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ae1e5b44f4f584318f9065bcf39c75c84">lossless_cast()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ace2aa7992959c35ebe5895999b762b34">make_bool()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a5a057ef6ceb8462dbca18eb9020bc297">make_const()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a01e5ab6b1524fd81132823c77c35d717">make_one()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a14bdd8230cefd6bf9f84ac909311d87e">make_two()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a0e4b9c03c76d9a19a0d7a7de2036f1b6">make_zero()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a365bfad96972abe9e008bb1b601223f9">match_types()</a>, <a class="el" href="namespace_halide_1_1_internal.html#aec662f503947166115071493eaa00780">raise_to_integer_power()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a839473cf858ba53326b678db072411d2">split_into_ands()</a>.</p>

</div>
</div>
<a class="anchor" id="a2de10096d923cdc0f02582981b718854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_representable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a constant value can be correctly represented as the given type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00705">Halide::max()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00752">Halide::min()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00619">Halide::operator!=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00433">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00348">Halide::operator*()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00261">Halide::operator+()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00299">Halide::operator-()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00400">Halide::operator/()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00495">Halide::operator&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01427">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00526">Halide::operator&lt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00588">Halide::operator==()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00464">Halide::operator&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00557">Halide::operator&gt;=()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01456">Halide::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="ace2aa7992959c35ebe5895999b762b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_bool </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a boolean constant from a C++ boolean value. </p>
<p>May also be a vector if width is given. It is not possible to coerce a C++ boolean to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> because if we provide such a path then char objects can ambiguously be converted to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or to std::string. The problem is that C++ does not have a real bool type - it is in fact close enough to char that C++ does not know how to distinguish them. make_bool is the explicit coercion. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e4b9c03c76d9a19a0d7a7de2036f1b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of zero in the given type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00646">Halide::operator&amp;&amp;()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00321">Halide::operator-()</a>.</p>

</div>
</div>
<a class="anchor" id="a01e5ab6b1524fd81132823c77c35d717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of one in the given type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00669">Halide::operator||()</a>.</p>

</div>
</div>
<a class="anchor" id="a14bdd8230cefd6bf9f84ac909311d87e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_two </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of two in the given type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a5fb413640f7f46493733fa33d95ea9fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::const_true </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the constant boolean true. </p>
<p>May also be a vector of trues, if a lanes argument is given. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="ab94c84e726218144cf4c5d3a08b38f8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::const_false </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the constant boolean false. </p>
<p>May also be a vector of falses, if a lanes argument is given. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1e5b44f4f584318f9065bcf39c75c84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lossless_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to cast an expression to a smaller type while provably not losing information. </p>
<p>If it can't be done, return an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00816">Halide::clamp()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a365bfad96972abe9e008bb1b601223f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::match_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coerce the two expressions to have the same type, using C-style casting rules. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> the purposes of casting, a boolean type is UInt(1). We use the following procedure:</p>
<p>If the types already match, do nothing.</p>
<p>Then, if one type is a vector and the other is a scalar, the scalar is broadcast to match the vector width, and we continue.</p>
<p>Then, if one type is floating-point and the other is not, the non-float is cast to the floating-point type, and we're done.</p>
<p>Then, if both types are unsigned ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Then, if both types are signed ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Finally, if one type is an unsigned int and the other type is a signed int, both are cast to a signed int with the greater of the two bit-widths. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, matching an Int(8) with a UInt(16) results in an Int(16). </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00853">Halide::absd()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01612">Halide::div_round_to_zero()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00693">Halide::max()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00740">Halide::min()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01632">Halide::mod_round_to_zero()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00609">Halide::operator!=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00423">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00638">Halide::operator&amp;&amp;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00339">Halide::operator*()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00251">Halide::operator+()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00290">Halide::operator-()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00379">Halide::operator/()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00485">Halide::operator&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01419">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00516">Halide::operator&lt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00578">Halide::operator==()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00454">Halide::operator&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00547">Halide::operator&gt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01448">Halide::operator&gt;&gt;()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00661">Halide::operator||()</a>.</p>

</div>
</div>
<a class="anchor" id="a1953dca5a0981d186fc050a1deace06b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="af0b9fcbf1259db14123bffa40c5bae56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c1307e62672d75c2f542f37430b3239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_erf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01183">Halide::erf()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="aec662f503947166115071493eaa00780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::raise_to_integer_power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise an expression to an integer power by repeatedly multiplying it by itself. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01204">Halide::fast_pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01160">Halide::pow()</a>.</p>

</div>
</div>
<a class="anchor" id="a839473cf858ba53326b678db072411d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::split_into_ands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs. </p>
<p>If 'cond' is undefined, return an empty vector. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00099">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4093d5c88fc8306429ca00725dbabbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::strided_ramp_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If e is a ramp expression with stride, default 1, return the base, otherwise undefined. </p>

</div>
</div>
<a class="anchor" id="acf7ed2ca593eca53111eaf753a7fc9bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01724">1724</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01728">collect_print_args()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01748">Halide::print()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01761">Halide::print_when()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01794">Halide::require()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d7c2f51029190ae224290688b7c4c3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>more_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01728">1728</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l01724">collect_print_args()</a>.</p>

</div>
</div>
<a class="anchor" id="adda140fdf727dfa11f6f3151fc4f7661"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>more_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01734">1734</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l01724">collect_print_args()</a>, and <a class="el" href="namespace_halide.html#ad933f903f12d02dc4a41950751feb8f9">Halide::print()</a>.</p>

</div>
</div>
<a class="anchor" id="a082d3bda0d60128ae127d0879e7e38c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::memoize_tag_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache_key_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01863">Halide::memoize_tag()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01827">Halide::undef()</a>.</p>

</div>
</div>
<a class="anchor" id="a83fe20393021d437778c0587afbc448d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_associative_pattern.html">AssociativePattern</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide associative pattern on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a4e3b530e690cbe977d889e0931f8933d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide associative op on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a10cfea8acb4f311a9365e26a8f7de08f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide for loop type (vectorized, serial, etc) in a human readable form. </p>

</div>
</div>
<a class="anchor" id="a6e1f893faca900eef051b7c0c182fde5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide name mangling value in a human readable format. </p>

</div>
</div>
<a class="anchor" id="a6f77f82c9290637ca0b5497f73a8f555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide linkage value in a human readable format. </p>

</div>
</div>
<a class="anchor" id="aea9af6e36531c5c2b17cc031c3d5e241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_lerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>zero_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>one_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> IR that computes a lerp. </p>
<p>Use by codegen targets that don't have a native lerp. </p>

</div>
</div>
<a class="anchor" id="a58d5d64835b9903431e1ae1477b15f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::loop_invariant_code_motion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist loop-invariants out of inner loops. </p>
<p>This is especially important in cases where LLVM would not do it for us automatically. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, it hoists loop invariants out of cuda kernels. </p>

</div>
</div>
<a class="anchor" id="a6e9d2c57ff18ef709b6a4e444f4af5ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Halide::Internal::iterator_to_pointer </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> -&gt; decltype(&amp;*std::declval&lt;T&gt;()) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00084">84</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a496ad11988df981c987a2557c3cd2d8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Triple Halide::Internal::get_triple_for_target </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the llvm::Triple that corresponds to the given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

</div>
</div>
<a class="anchor" id="a30b2ac324e660b73262abdb4b0643451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::Internal::get_initial_module_for_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_shared_jit_runtime</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>just_gpu</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for a given target. </p>

</div>
</div>
<a class="anchor" id="a9e77b70f4bfb715115d8c3a690b2faa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::Internal::get_initial_module_for_ptx_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for ptx device. </p>

</div>
</div>
<a class="anchor" id="af5c2253813b438bcb811778d84b98e94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::add_bitcode_to_module </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link a block of llvm bitcode into an llvm module. </p>

</div>
</div>
<a class="anchor" id="a1fc91c3863b2f3b6afe3902a717ff68b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::loop_carry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_carried_values</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reuse loads done on previous loop iterations by stashing them in induction variables instead of redoing the load. </p>
<p>If the loads are predicated, the predicates need to match. Can be an optimization or pessimization depending on how good the L1 cache is on the architecture and how many memory issue slots there are. Currently only intended for Hexagon. </p>

</div>
</div>
<a class="anchor" id="a599a108a4c15695c0530287344e2fbac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_module.html">Module</a> Halide::Internal::lower </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pipeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623c">LinkageType</a>&#160;</td>
          <td class="paramname"><em>linkage_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>custom_passes</em> = <code>std::vector&lt;&#160;<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a>&#160;*&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of scheduled halide functions, create a <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> that evaluates it. </p>
<p>Automatically pulls in all the functions f depends on. Some stages of lowering may be target-specific. The <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> may contain submodules for computation offloaded to another execution engine or API as well as buffers that are used in the passed in <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>. Multiple LoweredFuncs are added to support legacy <a class="el" href="structbuffer__t.html">buffer_t</a> calling convention. </p>

</div>
</div>
<a class="anchor" id="aa3579ee621d6531a4d635eb766640a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_main_stmt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pipeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>custom_passes</em> = <code>std::vector&lt;&#160;<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a>&#160;*&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a halide function with a schedule, create a statement that evaluates it. </p>
<p>Automatically pulls in all the functions f depends on. Some stages of lowering may be target-specific. Mostly used as a convenience function in tests that wish to assert some property of the lowered IR. </p>

</div>
</div>
<a class="anchor" id="a4d3bfe43201bab68cf4820993fe1469b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::lower_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7fa573630ec30c63bc99cd46a4217cbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_warp_shuffles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite access to things stored outside the loop over GPU lanes to use nvidia's warp shuffle instructions. </p>

</div>
</div>
<a class="anchor" id="a6a57c1db8b5f97b8003a5271907bfdda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261">llvm::Function</a>* Halide::Internal::define_matlab_wrapper </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261">llvm::Function</a> *&#160;</td>
          <td class="paramname"><em>pipeline_argv_wrapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_internal.html#ae02ee070dfadab621e55f3b3dd971e18a86408593c34af77fdd90df932f8b5261">llvm::Function</a> *&#160;</td>
          <td class="paramname"><em>metadata_getter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> a mexFunction wrapper definition to the module, calling the function with the name pipeline_name. </p>
<p>Returns the mexFunction definition. </p>

</div>
</div>
<a class="anchor" id="a585e65b645868795c02e73c853404321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_memoization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform pipeline calls for Funcs scheduled with memoize to do a lookup call to the runtime cache implementation, and if there is a miss, compute the results and call the runtime to store it back to the cache. </p>
<p>Should leave non-memoized Funcs unchanged. </p>

</div>
</div>
<a class="anchor" id="a0cb0d4310fbae915041f61f46dc96677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::rewrite_memoized_allocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This should be called after Storage Flattening has added Allocation IR nodes. </p>
<p>It connects the memoization cache lookups to the Allocations so they point to the buffers from the memoization cache and those buffers are released when no longer used. Should not affect allocations for non-memoized Funcs. </p>

</div>
</div>
<a class="anchor" id="a552b2c330fdb1275badc27cc1e92cd6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::modulus_remainder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, it is straight-forward to deduce that ((10*x + 2)*(6*y - 3) - 1) is congruent to five modulo six.</p>
<p>We get the most information when the modulus is large. E.g. if something is congruent to 208 modulo 384, then we also know it's congruent to 0 mod 8, and we can possibly use it as an index for an aligned load. If all else fails, we can just say that an integer is congruent to zero modulo one. </p>

<p>Referenced by <a class="el" href="_hexagon_alignment_8h_source.html#l00068">Halide::Internal::HexagonAlignmentAnalyzer::push()</a>.</p>

</div>
</div>
<a class="anchor" id="a8489fb5b4449835f26313a57e856c4b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::modulus_remainder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder: </p>

</div>
</div>
<a class="anchor" id="af210d0f6ae102d704259f49bb32adc2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::reduce_expr_modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

<p>Referenced by <a class="el" href="_hexagon_alignment_8h_source.html#l00027">Halide::Internal::HexagonAlignmentAnalyzer::is_aligned_impl()</a>.</p>

</div>
</div>
<a class="anchor" id="af7d47052fb0609cee3c7117c4f595e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::reduce_expr_modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>remainder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

</div>
</div>
<a class="anchor" id="a789149daec96e933f8758f71f8474dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::modulus_remainder_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3383c51a3621854507bf149283901fd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::gcd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The greatest common divisor of two integers. </p>

</div>
</div>
<a class="anchor" id="aea6d5d650979fec41ce02d02ac0b7c20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::lcm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The least common multiple of two integers. </p>

</div>
</div>
<a class="anchor" id="a40ee7edbeb93353d1cb6b1f6cbfbe525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> Halide::Internal::is_monotonic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6de4b237eafb498206aa2eb0c94b4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::is_monotonic_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a87590be371b78913eaab20e563f335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_parallelize_rvar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> can prove that it is safe to parallelize an update definition across a specific variable. </p>
<p>If this returns true, it's definitely safe. If this returns false, it may still be safe, but <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> couldn't prove it. </p>

</div>
</div>
<a class="anchor" id="a0ce66817377fbb1918bbe7510ab47b29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_call_arg_types </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate arguments to a call to a func, image or imageparam. </p>

</div>
</div>
<a class="anchor" id="a270c212209434d22a1d368e561bc75a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::has_likely_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if an expression uses a likely tag. </p>

</div>
</div>
<a class="anchor" id="a3d00fe3db9030d30827191d78c36fda5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::partition_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions loop bodies into a prologue, a steady state, and an epilogue. </p>
<p>Finds the steady state by hunting for use of clamped ramps, or the 'likely' intrinsic. </p>

</div>
</div>
<a class="anchor" id="ae9dd66428062b0d413dec72214c26f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_placeholder_prefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_prefetch_directive.html">PrefetchDirective</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefetches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject placeholder prefetches to 's'. </p>
<p>This placholder prefetch does not have explicit region to be prefetched yet. It will be computed during call to <a class="el" href="namespace_halide_1_1_internal.html#a00dbff02860c1622c6e4d1fba8ac01e3">inject_prefetch</a>. </p>

</div>
</div>
<a class="anchor" id="a00dbff02860c1622c6e4d1fba8ac01e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_prefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the actual region to be prefetched and place it to the placholder prefetch. </p>
<p>Wrap the prefetch call with condition when applicable. </p>

</div>
</div>
<a class="anchor" id="a23cbede92a4cd09354b032a40829a9d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::reduce_prefetch_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce a multi-dimensional prefetch into a prefetch of lower dimension (max dimension of the prefetch is specified by target architecture). </p>
<p>This keeps the 'max_dim' innermost dimensions and adds loops for the rest of the dimensions. If maximum prefetched-byte-size is specified (depending on the architecture), this also adds an outer loops that tile the prefetches. </p>

</div>
</div>
<a class="anchor" id="aa35ddfd891459204fae6afbcbdb6bac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::print_loop_nest </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_funcs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit some simple pseudocode that shows the structure of the loop nest specified by this pipeline's schedule, and the schedules of the functions it uses. </p>

<p>Referenced by <a class="el" href="_generator_8h_source.html#l01881">Halide::Internal::GeneratorOutputBase::as()</a>, and <a class="el" href="_func_8h_source.html#l00663">Halide::Func::Func()</a>.</p>

</div>
</div>
<a class="anchor" id="a568a0554db6866ee8560c3f599bceadd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_profiling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement representing a halide pipeline insert high-resolution timing into the generated code (via spawning a thread that acts as a sampling profiler); summaries of execution times and counts will be logged at the end. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a class="anchor" id="add0c1d3ac79fd83cb609d37831253957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::qualify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefix all variable names in the given expression with the prefix string. </p>

</div>
</div>
<a class="anchor" id="a795f343747d7f716a33198907c3e7d25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::random_float </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random floating-point number between zero and one that varies deterministically based on the input expressions. </p>

</div>
</div>
<a class="anchor" id="ae4e64539c6d89123f6200b919ec28fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::random_int </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers or unsigned integers). </p>

</div>
</div>
<a class="anchor" id="a0f875bf4d528885d68581fbd198bf356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>free_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> calls to random() to IR generated by random_float and random_int. </p>
<p>Tags all calls with the variables in free_vars, and the integer given as the last argument. </p>

</div>
</div>
<a class="anchor" id="a310daae8e7f187c090b63aa3514d639c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;std::string&gt;, std::vector&lt;std::vector&lt;std::string&gt; &gt; &gt; Halide::Internal::realization_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bunch of functions that call each other, determine an order in which to do the scheduling. </p>
<p>This in turn influences the order in which stages are computed when there's no strict dependency between them. Currently just some arbitrary depth-first traversal of the call graph. In addition, determine grouping of functions with fused computation loops. The functions within the fused groups are sorted based on realization order. There should not be any dependencies among functions within a fused group. This pass will also populate the 'fused_pairs' list in the function's schedule. Return a pair of the realization order and the fused groups in that order. </p>

</div>
</div>
<a class="anchor" id="a5a4634146d25cdc2f89c0501ad72ccde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Halide::Internal::topological_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bunch of functions that call each other, determine a topological order which stays constant regardless of the schedule. </p>
<p>This ordering adheres to the producer-consumer dependencies, i.e. producer will come before its consumers in that order </p>

</div>
</div>
<a class="anchor" id="aedcc74570e61290111488ef861e03d0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::split_predicate_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_reduction_8h_source.html#l00065">Halide::Internal::ReductionDomain::same_as()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b8bfb7d84886e922f43c911740f2b1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_func_trivial_to_inline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the cost of inlining a function is equivalent to the cost of calling the function directly. </p>

</div>
</div>
<a class="anchor" id="a8459c153113e252e4cf11fd16326b065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_dead_allocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Allocate/Free pairs that are never loaded from or stored to, and remove them from the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>. </p>
<p>This doesn't touch Realize/Call nodes and so must be called after storage_flattening. </p>

</div>
</div>
<a class="anchor" id="a445fa778b28abf135eb1b1d0c8389efc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_trivial_for_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_convert.html">Convert</a> for loops of size 1 into <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a> nodes, which allows for further simplification. </p>
<p>Done during a late stage of lowering. </p>

</div>
</div>
<a class="anchor" id="a078fe646230de310959c4506c76de02e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_undef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes stores that depend on undef values, and statements that only contain such stores. </p>

</div>
</div>
<a class="anchor" id="a9893105833167095e00bf8802a1294f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::schedule_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fused_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>any_memoized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build loop nests and inject <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> realizations at the appropriate places using the schedule. </p>
<p>Returns a flag indicating whether memoization passes need to be run. </p>

</div>
</div>
<a class="anchor" id="a4242a0b28a7409d2a2489a74795914ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_scope_8h_source.html#l00269">269</a> of file <a class="el" href="_scope_8h_source.html">Scope.h</a>.</p>

<p>References <a class="el" href="_scope_8h_source.html#l00203">Halide::Internal::Scope&lt; T &gt;::const_iterator::name()</a>.</p>

</div>
</div>
<a class="anchor" id="a6961bbda74000b883fc5759884e4a0b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::select_gpu_api </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace for loops with GPU_Default device_api with an actual device API depending on what's enabled in the target. </p>
<p>Choose the first of the following: opencl, cuda, openglcompute, opengl </p>

</div>
</div>
<a class="anchor" id="ab4c523ca09c58b10c6786b259296dba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::simple_autoschedule_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a281c43601ef9ba6a584dbfa8ecd39e1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_dead_lets</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>
<p>Simplifies across let statements, so must not be called on stmts with dangling or repeated variable names. </p>

</div>
</div>
<a class="anchor" id="a6405a74f3c241d60365e510a4e698808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_dead_lets</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>
<p>Simplifies across let statements, so must not be called on stmts with dangling or repeated variable names. </p>

</div>
</div>
<a class="anchor" id="a00d69e4eec54945f92a3b5e4fb7e3e69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_prove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A common use of the simplifier is to prove boolean expressions are true at compile time. </p>
<p>Equivalent to is_one(simplify(e)) </p>

</div>
</div>
<a class="anchor" id="a0faf83270a59e0cf2e3821be2a4666c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify_exprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify expressions found in a statement, but don't simplify across different statements. </p>
<p>This is safe to perform at an earlier stage in lowering than full simplification of a stmt. </p>

</div>
</div>
<a class="anchor" id="a6cd3908859c82249a2c7f10158883a97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::mod_imp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>. </p>
<p>Use these implementations; do not use native C division or mod to simplify <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> expressions. <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> division and modulo satisify the Euclidean definition of division for integers a and b:</p>
<p>/code (a/b)*b + ab = a 0 &lt;= ab &lt; |b| /endcode </p>

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00054">54</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00836">Halide::abs()</a>, <a class="el" href="runtime__internal_8h_source.html#l00188">Halide::Runtime::Internal::b</a>, and <a class="el" href="_type_8h_source.html#l00353">Halide::Type::is_int()</a>.</p>

</div>
</div>
<a class="anchor" id="a0442f9a0450f45683938a69ce0273974"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::div_imp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>. </p>
<p>Use these implementations; do not use native C division or mod to simplify <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> expressions. <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> division and modulo satisify the Euclidean definition of division for integers a and b:</p>
<p>/code (a/b)*b + ab = a 0 &lt;= ab &lt; |b| /endcode </p>

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00066">66</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00188">Halide::Runtime::Internal::b</a>, <a class="el" href="_type_8h_source.html#l00312">Halide::Type::bits()</a>, and <a class="el" href="_type_8h_source.html#l00353">Halide::Type::is_int()</a>.</p>

</div>
</div>
<a class="anchor" id="adff5495089b812474881ee939c4701c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00081">81</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00188">Halide::Runtime::Internal::b</a>.</p>

</div>
</div>
<a class="anchor" id="ac9a60708c880da445554b8eeb778c034"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00086">86</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00188">Halide::Runtime::Internal::b</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01236">Halide::floor()</a>.</p>

</div>
</div>
<a class="anchor" id="aa13a82f37fe6336c154122f66d294523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00091">91</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00188">Halide::Runtime::Internal::b</a>.</p>

</div>
</div>
<a class="anchor" id="a3965c871f086a60fda2cc31e678d050a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00094">94</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00188">Halide::Runtime::Internal::b</a>.</p>

</div>
</div>
<a class="anchor" id="af4259425c64a0a9b25760e1c38123c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::simplify_specializations </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to simplify the RHS/LHS of a function's definition based on its specializations. </p>

</div>
</div>
<a class="anchor" id="a8489422fe4da6e486b5fd7831aab8bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::skip_stages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used. </p>
<p>Does this by analyzing all reads of each buffer allocated, and inferring some condition that tells us if the reads occur. If the condition is non-trivial, inject ifs that guard the production. </p>

</div>
</div>
<a class="anchor" id="a07bde9012b280aad21a569ea008ed296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::sliding_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sliding window optimizations on a halide statement. </p>
<p>I.e. don't bother computing points in a function that have provably already been computed by a previous iteration. </p>

</div>
</div>
<a class="anchor" id="a7f45851f86c88f06e8943d7a73fef4d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a> Halide::Internal::solve_expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt;&#160;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to collect all instances of a variable in an expression tree and place it as far to the left as possible, and as far up the tree as possible (i.e. </p>
<p>outside most parentheses). If the expression is an equality or comparison, this 'solves' the equation. Returns a pair of <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> and bool. The <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> is the mutated expression, and the bool indicates whether there is a single instance of the variable in the result. If it is false, the expression has only been partially solved, and there are still multiple instances of the variable. </p>

</div>
</div>
<a class="anchor" id="a802d19074b31d2fda334b5a4cb80aef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::solve_for_outer_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the smallest interval such that the condition is either true or false inside of it, but definitely false outside of it. </p>
<p>Never returns undefined Exprs, instead it uses variables called "pos_inf" and "neg_inf" to represent positive and negative infinity. </p>

</div>
</div>
<a class="anchor" id="a1304566ace35a6571c30fb6e1e37d031"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::solve_for_inner_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the largest interval such that the condition is definitely true inside of it, and might be true or false outside of it. </p>

</div>
</div>
<a class="anchor" id="abed16d941f9de01188d0d4cc265d4c6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::and_condition_over_domain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>varying</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a conditional that includes variables that vary over some domain, and convert it to a more conservative (less frequently true) condition that doesn't depend on those variables. </p>
<p>Formally, the output expr implies the input expr.</p>
<p>The condition may be a vector condition, in which case we also 'and' over the vector lanes, and return a scalar result. </p>

</div>
</div>
<a class="anchor" id="a6e1e287e68d69ec35fd8a1e62d1c30ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::solve_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3be8910393f0a765042cca2d9aa035ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::split_tuples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite all tuple-valued Realizations, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location. ">Provide</a> nodes, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a> nodes into several scalar-valued ones, so that later lowering passes only need to think about scalar-valued productions. </p>

</div>
</div>
<a class="anchor" id="abce34a586ac31d591af744c10b3e5ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::print_to_html </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump an HTML-formatted print of a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> to filename. </p>

</div>
</div>
<a class="anchor" id="ac8dce696b85774255e849b8e13737595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::print_to_html </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump an HTML-formatted print of a <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to filename. </p>

</div>
</div>
<a class="anchor" id="ac8cb6fe2cb6171bf79124c2c1b1e867f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::storage_flattening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location. ">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39; if &#39;predicate&#39; is true. ">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named symbol if predicate is true. ">Load</a> nodes respectively. </p>

</div>
</div>
<a class="anchor" id="a003d25ab32344023873b630df8fc5719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::storage_folding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold storage of functions if possible. </p>
<p>This means reducing one of the dimensions module something for the purpose of storage, if we can prove that this is safe to do. E.g consider:</p>
<div class="fragment"><div class="line">f(x) = ...</div><div class="line">g(x) = f(x-1) + f(x)</div><div class="line">f.store_root().compute_at(g, x);</div></div><!-- fragment --><p>We can store f as a circular buffer of size two, instead of allocating space for all of it. </p>

</div>
</div>
<a class="anchor" id="ad8a5dab8c12346254d9348060878045c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::strictify_float </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate strict_float intrinisics such that they immediately wrap all floating-point expressions. </p>
<p>This makes the IR nodes context independent. If the <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6e99d2e5d2365e4b2cf9fb7dbe1671c4">Target::StrictFloat</a> flag is specified in target, starts in strict_float mode so all floating-point type Exprs in the compilation will be marked with strict_float. Returns whether any strict floating-point is used in any function in the passed in env. </p>

</div>
</div>
<a class="anchor" id="ab77fafc3670bd07362c388820dd10c11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within expr. </p>
<p>This is a dangerous thing to do if variable names have not been uniquified. While it won't traverse inside let statements with the same name as the first argument, moving a piece of syntax around can change its meaning, because it can cross lets that redefine variable names that it includes references to. </p>

<p>Referenced by <a class="el" href="_function_8h_source.html#l00271">Halide::Internal::Function::operator ExternFuncArgument()</a>.</p>

</div>
</div>
<a class="anchor" id="a953484f8812539e108a6c4e137ebfc62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within stmt. </p>

</div>
</div>
<a class="anchor" id="a92d044309ede4782cabce475570934a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a class="anchor" id="a14ebb6536c3233e6466073757f0e59e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a class="anchor" id="a07967ab74e22a0103d6af67ec62cc3b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute expressions for other expressions. </p>

</div>
</div>
<a class="anchor" id="ae1b12ab6ef3f59e897315145d1e996e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute expressions for other expressions. </p>

</div>
</div>
<a class="anchor" id="a457e67268c787fe55a7bc5e3559f43cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutions where the IR may be a general graph (and not just a DAG). </p>

</div>
</div>
<a class="anchor" id="a95627cc6470e3f8975ab3b1fa2048e3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutions where the IR may be a general graph (and not just a DAG). </p>

</div>
</div>
<a class="anchor" id="a8219abd8f63bb237e29a7b878a445836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutions where the IR may be a general graph (and not just a DAG). </p>

</div>
</div>
<a class="anchor" id="a1d8e9db71fa11a9eb45590a8fd5ff774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutions where the IR may be a general graph (and not just a DAG). </p>

</div>
</div>
<a class="anchor" id="aaafce6d574b476cf9c9acd5f622450ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_in_all_lets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute in all let Exprs in a piece of IR. </p>
<p>Doesn't substitute in let stmts, as this may change the meaning of the IR (e.g. by moving a load after a store). Produces graphs of IR, so don't use non-graph-aware visitors or mutators on it until you've CSE'd the result. </p>

</div>
</div>
<a class="anchor" id="a6a57aa0cf600e63ac832ea799f354acc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute_in_all_lets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute in all let Exprs in a piece of IR. </p>
<p>Doesn't substitute in let stmts, as this may change the meaning of the IR (e.g. by moving a load after a store). Produces graphs of IR, so don't use non-graph-aware visitors or mutators on it until you've CSE'd the result. </p>

</div>
</div>
<a class="anchor" id="ae0ca85eaf8baf3957bda33b83b20c694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::target_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_target_8h_source.html#l00220">Halide::Target::maximum_buffer_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ada4e76111f95056b99d8f1fdf108285e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_tracing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pipeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>Target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a class="anchor" id="aae7fd6fdb5eb7b96d5dcf4a9d52985f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::trim_no_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate loop bounds to the region over which they actually do something. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> examples see test/correctness/trim_no_ops.cpp </p>

</div>
</div>
<a class="anchor" id="a0b6c445013b15af0a32bd54f5bb6bdc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unify_duplicate_lets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones. </p>

</div>
</div>
<a class="anchor" id="abf197e316b7d0a6adb96c25976612c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::uniquify_variable_names </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a statement so that every internally-defined variable name is unique. </p>
<p>This lets later passes assume syntactic equivalence is semantic equivalence. </p>

</div>
</div>
<a class="anchor" id="a49ffc3710f4a568f3e626e253bc758c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unpack_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates let stmts for the various buffer components (e.g. </p>
<p>foo.extent.0) in any referenced concrete buffers or buffer parameters. After this pass, the only undefined symbols should scalar parameters and the buffers themselves (e.g. foo.buffer). </p>

</div>
</div>
<a class="anchor" id="adc1c49e552297672b3751ac988bf70c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unroll_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement. </p>
<p>I.e. unroll the loop. </p>

</div>
</div>
<a class="anchor" id="a7a562085de28dc619511f71c4403fe38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower_unsafe_promises </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower all unsafe promises into either assertions or unchecked code, depending on the target. </p>

</div>
</div>
<a class="anchor" id="ab7501900efa7660edf445ed1b14c020c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DST , typename SRC , typename std::enable_if&lt; std::is_floating_point&lt; SRC &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DST Halide::Internal::safe_numeric_cast </td>
          <td>(</td>
          <td class="paramtype">SRC&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some numeric conversions are UB if the value won't fit in the result; <a class="el" href="namespace_halide_1_1_internal.html#ab7501900efa7660edf445ed1b14c020c" title="Some numeric conversions are UB if the value won&#39;t fit in the result; safe_numeric_cast&lt;&gt;() is meant ...">safe_numeric_cast&lt;&gt;()</a> is meant as a drop-in replacement for a C/C++ cast that adds well-defined behavior for the UB cases, attempting to mimic common implementation behavior as much as possible. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00059">59</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_func_8h_source.html#l00533">Halide::max()</a>, and <a class="el" href="_func_8h_source.html#l00532">Halide::min()</a>.</p>

</div>
</div>
<a class="anchor" id="a94816d6979fdadb6e206a5d0a668e008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DstType , typename SrcType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DstType Halide::Internal::reinterpret_bits </td>
          <td>(</td>
          <td class="paramtype">const SrcType &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An aggressive form of reinterpret cast used for correct type-punning. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00095">95</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="printer_8h_source.html#l00030">dst</a>, <a class="el" href="namespace_halide_1_1_internal.html#a290fb244405de2c014ebdc3cd1fc8f08">ends_with()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a8c7c63ee87658cd904e2f4a0ba78b78b">get_env_variable()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a18d7dfc983d7a320ea1510c24bc55625">make_entity_name()</a>, <a class="el" href="runtime__internal_8h.html#add55236e1a6168d059f1409762081d1a">memcpy()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a9c06bf852ad18eb3e9014495f5816c1f">replace_all()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab4b793745b048fa1fd344907ec4ec9aa">running_program_name()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a403191721c99e2a88864db3bafbf7b0e">split_string()</a>, <a class="el" href="namespace_halide_1_1_internal.html#af26ca52c958b993ebd766f4b83de2cf9">starts_with()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#aabd490221160a7206bb151d6eae65624">unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="a18d7dfc983d7a320ea1510c24bc55625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::make_entity_name </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a unique name for an object based on the name of the stack variable passed in. </p>
<p>If introspection isn't working or there are no debug symbols, just uses unique_name with the given prefix. </p>

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00141">Halide::Buffer&lt;&gt;::Buffer()</a>, and <a class="el" href="_util_8h_source.html#l00095">reinterpret_bits()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c7c63ee87658cd904e2f4a0ba78b78b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::get_env_variable </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>env_var_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value of an environment variable. </p>
<p>Returns its value is defined in the environment. If the var is not defined, an empty string is returned. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00095">reinterpret_bits()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4b793745b048fa1fd344907ec4ec9aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::running_program_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the currently running executable. </p>
<p>Platform-specific. If program name cannot be retrieved, function returns an empty string. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00095">reinterpret_bits()</a>.</p>

</div>
</div>
<a class="anchor" id="aabd490221160a7206bb151d6eae65624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::unique_name </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a unique name starting with the given prefix. </p>
<p>It's unique relative to all other strings returned by unique_name in this process.</p>
<p>The single-character version always appends a numeric suffix to the character.</p>
<p>The string version will either return the input as-is (with high probability on the first time it is called with that input), or replace any existing '$' characters with underscores, then add a '$' sign and a numeric suffix to it.</p>
<p>Note that unique_name('f') therefore differs from unique_name("f"). The former returns something like f123, and the latter returns either f or f$123. </p>

<p>Referenced by <a class="el" href="_lambda_8h_source.html#l00017">Halide::lambda()</a>, and <a class="el" href="_util_8h_source.html#l00095">reinterpret_bits()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ec0bd73d997ddc50f3523a21448471f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::unique_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a unique name starting with the given prefix. </p>
<p>It's unique relative to all other strings returned by unique_name in this process.</p>
<p>The single-character version always appends a numeric suffix to the character.</p>
<p>The string version will either return the input as-is (with high probability on the first time it is called with that input), or replace any existing '$' characters with underscores, then add a '$' sign and a numeric suffix to it.</p>
<p>Note that unique_name('f') therefore differs from unique_name("f"). The former returns something like f123, and the latter returns either f or f$123. </p>

</div>
</div>
<a class="anchor" id="af26ca52c958b993ebd766f4b83de2cf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the first string starts with the second string. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00095">reinterpret_bits()</a>.</p>

</div>
</div>
<a class="anchor" id="a290fb244405de2c014ebdc3cd1fc8f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the first string ends with the second string. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00095">reinterpret_bits()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c06bf852ad18eb3e9014495f5816c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches of the second string in the first string with the last string. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00095">reinterpret_bits()</a>.</p>

</div>
</div>
<a class="anchor" id="a403191721c99e2a88864db3bafbf7b0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Halide::Internal::split_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00095">reinterpret_bits()</a>.</p>

</div>
</div>
<a class="anchor" id="aaaee1bb2b0dc659851899df7c12437ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::fold_left </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a left fold of a vector. </p>
<p>Returns a default-constructed vector element if the vector is empty. Similar to std::accumulate but with a less clunky syntax. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00154">154</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="afedfcf82469516f0f05eb5a4699f480a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::fold_right </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a right fold of a vector. </p>
<p>Returns a default-constructed vector element if the vector is empty. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00169">169</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada89faf6db79c27c47db4f29e18dea92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_paired_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>collected_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00182">182</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00188">collect_paired_args()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00108">Halide::BoundaryConditions::constant_exterior()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00222">Halide::BoundaryConditions::mirror_image()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00260">Halide::BoundaryConditions::mirror_interior()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00152">Halide::BoundaryConditions::repeat_edge()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00187">Halide::BoundaryConditions::repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a8de410db20153cd4fa493607e75c962b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> void Halide::Internal::collect_paired_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>collected_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00188">188</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00182">collect_paired_args()</a>.</p>

</div>
</div>
<a class="anchor" id="a93192a2ea0afe58664e69232595ae08e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::extract_namespaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns base name and fills in namespaces, outermost one first in vector. </p>

<p>Referenced by <a class="el" href="_type_8h_source.html#l00194">halide_handle_cplusplus_type::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f8aad349dd3bfc69483b792fcab0f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::file_make_temp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically /tmp, but the specific location is not guaranteed. </p>
<p>(Note that the exact form of the file name may vary; in particular, the suffix may be ignored on Windows.) The file is created (but not opened), thus this can be called from different threads (or processes, e.g. when building with parallel make) without risking collision. Note that if this file is used as a temporary file, the caller is responsibly for deleting it. Neither the prefix nor suffix may contain a directory separator. </p>

</div>
</div>
<a class="anchor" id="abaf8a5ee39d2b222d8a0be57894a2f75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::dir_make_temp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique directory in an arbitrary (but writable) directory; this is typically somewhere inside /tmp, but the specific location is not guaranteed. </p>
<p>The directory will be empty (i.e., this will never return /tmp itself, but rather a new directory inside /tmp). The caller is responsible for removing the directory after use. </p>

</div>
</div>
<a class="anchor" id="aff2a323363444e3d16237848f6f8715b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for access(). </p>
<p>Quietly ignores errors. </p>

</div>
</div>
<a class="anchor" id="a034796c3683c3301a09c0102c6adb8b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assert_file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assert-fail if the file doesn't exist. </p>
<p>useful primarily for testing purposes. </p>

</div>
</div>
<a class="anchor" id="ab8356033bf440e2f990bdc9f27cdcdcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assert_no_file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assert-fail if the file DOES exist. </p>
<p>useful primarily for testing purposes. </p>

</div>
</div>
<a class="anchor" id="a05dd8ec86534a0e22d1ab4f2037bc562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::file_unlink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for unlink(). </p>
<p>Asserts upon error.</p>
<p>Quietly ignores errors. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00276">Halide::Internal::TemporaryFile::~TemporaryFile()</a>.</p>

</div>
</div>
<a class="anchor" id="a947c611b7403f5613f08fb701ea6eed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::ensure_no_file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that no file with this path exists. </p>
<p>If such a file exists and cannot be removed, assert-fail. </p>

</div>
</div>
<a class="anchor" id="a710588d377ce398aa366fc00f6d436aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::dir_rmdir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for rmdir(). </p>
<p>Asserts upon error. </p>

</div>
</div>
<a class="anchor" id="aa0f41b4199ab2236fb4056661f20cc11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a> Halide::Internal::file_stat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for stat(). </p>
<p>Asserts upon error. </p>

</div>
</div>
<a class="anchor" id="a8cc678d669d07fdd15685b87e3b8b620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::add_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines to test if math would overflow for signed integers with the given number of bits. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00280">Halide::Internal::TemporaryFile::detach()</a>.</p>

</div>
</div>
<a class="anchor" id="a82c64641e261b5596a2ab6d7da7f8ef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::sub_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines to test if math would overflow for signed integers with the given number of bits. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00280">Halide::Internal::TemporaryFile::detach()</a>.</p>

</div>
</div>
<a class="anchor" id="a9aaa735c9ff93372dce25222fb551b67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::mul_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines to test if math would overflow for signed integers with the given number of bits. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00280">Halide::Internal::TemporaryFile::detach()</a>.</p>

</div>
</div>
<a class="anchor" id="ae342a753f8441a0b29418b0d22cbda86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::halide_tic_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7c23694d45bd4c42ec1dc97a17bb78f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::halide_toc_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7006f0b4b15257feedd9e57d1288dc97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_halide_1_1_var.html">Var</a>&gt; Halide::Internal::make_argument_list </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensionality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a list of unique arguments for definitions with unnamed arguments. </p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01129">Halide::Func::define_extern()</a>, and <a class="el" href="_var_8h_source.html#l00165">Halide::Var::outermost()</a>.</p>

</div>
</div>
<a class="anchor" id="adcfef059a37f995f9434f836bdbc1edd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::find_linear_expressions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal.html#adcfef059a37f995f9434f836bdbc1edd" title="find_linear_expressions(Stmt s) identifies expressions that may be moved out of the generated fragmen...">find_linear_expressions(Stmt s)</a> identifies expressions that may be moved out of the generated fragment shader into a varying attribute. </p>
<p>These expressions are tagged by wrapping them in a glsl_varying intrinsic </p>

</div>
</div>
<a class="anchor" id="a523c0d5dea7bfbd664e8506ebb7016de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::setup_gpu_vertex_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a set of 2D mesh coordinates based on the behavior of varying attribute expressions contained within a GLSL scheduled for loop. </p>
<p>This method is called during lowering to extract varying attribute expressions and generate code to evalue them at each mesh vertex location. The operation is performed on the host before the draw call to invoke the shader </p>

</div>
</div>
<a class="anchor" id="ae1d8d64a1298f1e0abd71fd0eeada10b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::vectorize_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors. </p>
<p>The loops in question must have constant extent. </p>

</div>
</div>
<a class="anchor" id="a47ba0a978ebdc5f1866290752bd76e6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::wrap_func_calls </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace every call to wrapped Functions in the Functions' definitions with call to their wrapper functions. </p>

</div>
</div>
<a class="anchor" id="af194834e3759a2a96d3929d8c9938395"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::wrap_legacy_extern_stages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_module.html">Module</a>&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> wrappers for any LoweredFuncs that need them to support backwards compatibility. </p>
<p>This currently wraps extern calls to stages that expect the old <a class="el" href="structbuffer__t.html">buffer_t</a> type. </p>

</div>
</div>
<a class="anchor" id="afe6fd6e0ae9234b9b435b13f432ae199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::add_legacy_wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_module.html">Module</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> a wrapper for a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function. ">LoweredFunc</a> that accepts old buffers and upgrades them. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ac4e8d52841afa71f1f7bac7ce9611159"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Internal::unknown = std::numeric_limits&lt;<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&gt;::<a class="el" href="namespace_halide.html#ab6f20de22e199a01ee4b40d61011ed69">min</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_auto_schedule_utils_8h_source.html#l00022">22</a> of file <a class="el" href="_auto_schedule_utils_8h_source.html">AutoScheduleUtils.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
